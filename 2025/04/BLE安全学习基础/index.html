
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>BLE安全学习基础 | ch0en3&#39;s blog</title>
    <meta name="author" content="ch0en3" />
    <meta name="description" content="" />
    <meta name="keywords" content="hacker/geeker" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="ch0en3's blog" type="application/atom+xml">
</head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>CH0EN3&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;CH0EN3&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>BLE安全学习基础</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/4/24
        </span>
        
        <span class="category">
            <a href="/categories/bluetooth/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                bluetooth
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/bluetooth/" style="color: #ff7d73">
                    bluetooth
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="协议栈基础介绍"><a href="#协议栈基础介绍" class="headerlink" title="协议栈基础介绍"></a>协议栈基础介绍</h1><p>一个BLE应用首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后基于协议栈开发自己的应用。BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。BLE协议栈主要用来对你的应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。 </p>
<p>蓝牙协议规定了两个层次的协议，分别为蓝牙核心协议（Bluetooth Core）和蓝牙应用层协议（Bluetooth Application）。蓝牙核心协议关注对蓝牙核心技术的描述和规范，它只提供基础的机制，并不关心如何使用这些机制；蓝牙应用层协议，是在蓝牙核心协议的基础上，根据具体的应用需求，百花齐放，定义出各种各样的策略，如FTP、文件传输、局域网等等。</p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000016846.png"></p>
<p> 蓝牙核心协议（Bluetooth Core）又包含BLE Controller和BLE Host两部分。这两部分在不同的蓝牙技术中（BR&#x2F;EDR、AMP、LE），承担角色略有不同，但大致的功能是相同的。Controller负责定义RF、Baseband等偏硬件的规范，并在这之上抽象出用于通信的逻辑链路（Logical Link）；Host负责在逻辑链路的基础上，进行更为友好的封装，这样就可以屏蔽掉蓝牙技术的细节，让Bluetooth Application更为方便的使用。  </p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000017104.jpeg" alt="画板"></p>
<p><strong>BLE低功耗蓝牙核心协议层详解（Bluetooth Core）</strong></p>
<p>**物理层（Physical Layer，简写 PHY）：**PHY用来指定BLE所用的无线频段，调制解调方式和方法等。例如是1Mbps自适应跳频的GFSK射频，工作于免许可证的2.4GHz ISM（工业、科学与医疗）频段。   PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。  </p>
<p><strong>链路层（Link Layer，简写 LL）:LL是BLE协议栈的核心。LL要层要做的事情很多，</strong> 比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者GATT。</p>
<p><strong>主机控制接口层（Host Controller Interface，简写 HCI）</strong>：HCI是可选的，HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。  </p>
<p>**通用访问配置文件层（Generic access profile，简写GAP）：**GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且只有简单的那一种，GAP简单的对LL的payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。</p>
<p><strong>逻辑链路控制及自适应协议层（Logical Link Control and Adaptation Protocol，简写 L2CAP）：L2CAP对LL惊醒了一次简单封装，LL只关心传输的数据本身，L2CAP就是要区分是加密通道还是普通通道，同时还对连接间隔进行管理。</strong></p>
<p><strong>安全管理层（Security Manager，简写 SM）：SM用来管理BLE连接的加密和安全。入和保证连接的安全性同时不影响用户的体验这些都是SMP要考虑的工作</strong></p>
<p><strong>属性协议层（Attribute protocol，简写 ATT）:ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE引用了attribute概念用来描述一条条的数据。attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层</strong></p>
<p><strong>通用属性配置文件层（Generic Attribute profile，简写 GATT）</strong>：  GATT用来规范attribute中的数据内容并运用group(分组)的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但是互联互通就会出现问题</p>
<h1 id="BLE协议栈如何完成发送任务"><a href="#BLE协议栈如何完成发送任务" class="headerlink" title="BLE协议栈如何完成发送任务"></a>BLE协议栈如何完成发送任务</h1><p>假设存在设备A和设备B， 设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B 。对于开发者来说这个过程越简单越好，最好是直接调用一个API就行， 比如send(0x53)，实际上我们的BLE协议栈就是这样设计的，开发者只需调用send(0x53)就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去，就如下图所示：  </p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000014137.png"></p>
<p>但是这种方式实际是不可行的。首先它没有考虑使用哪个射频信道进行传输，不更改API的情况下我们只能对协议栈进行分层，为此引入LL层，开发者还是调用send(0x53)，send(0x53)再调用send_LL(0x53,2402M) 。 这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入<strong>access address概念，用来指明接收者身份</strong>，其中，<strong>0x8E89BED6</strong>这个access address比较特殊，它表示要发给周边所有设备，即广播。如果你要一对一的进行通信（BLE协议将其称为<strong>连接</strong>），即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须生成一个独特的<strong>随机</strong>access address以标识设备A和设备B两者之间的连接。  </p>
<h2 id="广播方式"><a href="#广播方式" class="headerlink" title="广播方式"></a>广播方式</h2><p>假设设备A为<strong>advertiser</strong>（广播者） ， 设备B叫<strong>scanner</strong>或者<strong>observer</strong>（扫描者）。 广播状态下设备A的LL层API将变成send_LL(<strong>0x53,2402M</strong>, <strong>0x8E89BED6</strong>)  。 由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的device address（<strong>0xE1022AAB753B</strong>）以确认该广播包来自设备A，为此send_LL参数需要变成(<strong>0x53,2402M</strong>, <strong>0x8E89BED6</strong>, <strong>0xE1022AAB753B</strong>)。  LL层还要检查设备的完整性， 即数据在传输过程中有没有发生窜改，为此引入<strong>CRC24</strong>对数据包进行检验 (假设为<strong>0xB2C78E</strong>) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble（前导帧），preamble一般为<strong>0x55</strong>或者<strong>0xAA</strong>。这样，整个空中包就变成（注：<strong>空中包用小端模式表示（小端模式低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。）</strong>）：  </p>
<details class="lake-collapse"><summary id="u10eb5a38"><span class="ne-text">大小端的不同</span></summary><p id="u65de905e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29413051/1672209202074-208e0387-2c63-4be0-9805-25d9ee28caa1.jpeg" width="1041" id="u54861fd8" class="ne-image"></p></details>
![](https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000018143.png)

<p>上面这个数据包还有如下问题：</p>
<ul>
<li>没有对数据包进行分类组织，设备B无法找到自己想要的数据0x53。为此我们需要在access address之后加入两个字段：LL header和长度字节。LL header用来表示数据包的LL类型，长度字节用来指明payload的长度  </li>
<li>设备B什么时候开启射频窗口以接收空中数据包？如上图case1所示，当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；同样对case2来说，当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有case3的情况，通信才能成功，即设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，<strong>LL层还必须定义通信时序</strong>。</li>
<li>当设备B拿到数据0x53后，该如何解析这个数据呢？它到底表示湿度还是电量，还是别的意思？这个就是GAP层要做的工作。 <strong>GAP层引入了LTV（Length-Type-Value）结构来定义数据</strong>，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值 。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。  </li>
<li>最终空中传输的数据包将变成：</li>
<li>AAD6BE898E600E3B75AB2A02E102010504FF5900<strong>53</strong>8EC7B2 <ul>
<li>AA – 前导帧(preamble)</li>
<li>D6BE898E – 访问地址(access address)</li>
<li>60 – LL帧头字段(LL header)</li>
<li>0E – 有效数据包长度(payload length)</li>
<li>3B75AB2A02E1 – 广播者设备地址(advertiser address)</li>
<li>02010504FF5900**53 – **<strong>广播数据</strong></li>
<li>8EC7B2 – CRC24值</li>
<li><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000020838.png"></li>
</ul>
</li>
</ul>
<p>有了PHY,LL，和GAP就可以发送广播包了，但是还是会有几个限制</p>
<ul>
<li>1.无法进行一对一双向通信（广播是一对多通信，而且是单方向的）</li>
<li>不支持组包和拆包，无法传输大数据</li>
<li>通信不可靠且效率低下。广播信道不能太多否则导致扫描段效率低下。为此 BLE只使用37(2402MHz) &#x2F;38(2426MHz) &#x2F;39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。  </li>
<li>扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37&#x2F;38&#x2F;39三个通道进行扫描，这样功耗就会比较高。</li>
</ul>
<p>而连接可以解决以上问题。</p>
<h2 id="BLE连接方式"><a href="#BLE连接方式" class="headerlink" title="BLE连接方式"></a>BLE连接方式</h2><p>什么叫连接？像UART很容易理解，用线（rx和tx等）把设备A和设备B相连，就叫做连接。所谓设备A和设备B建立蓝牙连接就是指两个设备一对一同步成功，其具体包含一下几个方面</p>
<ol>
<li>设备A和B对接下来使用的物理信道一致</li>
<li>设备A和设备B双方建立一个共同的时间锚点，也就是说把双方的时间原点变成同一个点</li>
<li>设备A和B两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包</li>
<li>连接成功后，设备A和B通信流程如图所示</li>
<li><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000022937.png"></li>
</ol>
<p>如图所示， 一旦设备A和设备B连接成功（此种情况下，我们把设备A称为<strong>Master</strong>或者<strong>Central</strong>，把设备B称为<strong>Slave</strong>或者<strong>Peripheral</strong>） ，设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包。  同时按照蓝牙spec要求，设备B收到设备A数据包150us后设备B切换发送状态把自己的数据发给设备A；设备A则切换到接收状态接收设备B发过来的数据。可以看到连接状态下设备A和B的射频发送和接收窗口都是周期性的有计划的开和关并且开的时间非常短从而大大降低设备功</p>
<ul>
<li>对开发者来说，很简单，他只需要调用send(0x53)</li>
<li>GATT层定义数据的类型和分组，方便起见，我们用0x0013标识电量这种数据类型，这样GATT层把数据打包成130053（小端模式）</li>
<li>ATT层用来选择具体的通信命令，比如读写 比如读&#x2F;写&#x2F;notify&#x2F;indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053  </li>
<li>L2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053</li>
<li>LL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个**Access address（0x50655DAB）**以标识此连接只为设备A 和设备B 直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：</li>
</ul>
<p>o  AAAB5D65501E08040004001B130053D550F6    </p>
<p> o  AA – 前导帧(preamble)  </p>
<p> o  0x50655DAB – 访问地址(access address)  </p>
<p> o  1E – LL帧头字段(LL header)  </p>
<p> o  08 – 有效数据包长度(payload length)</p>
<p> o  04000400 – ATT数据长度，以及L2CAP通道编号</p>
<p>  o  1B – notify command</p>
<p>o  0x0013 – 电量数据handle</p>
<p> o  0x53 – 真正要发送的电量数据</p>
<p> o  0xF650D5 – CRC24值</p>
<h1 id="BLE工作流程"><a href="#BLE工作流程" class="headerlink" title="BLE工作流程"></a>BLE工作流程</h1><h2 id="1-角色"><a href="#1-角色" class="headerlink" title="1.角色"></a>1.角色</h2><p>BLE设备角色主要分为两种角色，主机（Master或Central）和从机（Peripheral），当主机和从机建立连接之后才能相互收发数据 </p>
<ul>
<li>主机，主机可以发起对从机的扫描连接。例如手机，通常作为BLE的主机设备</li>
<li>从机，从机只能广播并等待主机的连接。例如智能手环，是作为BLE的从机设备</li>
</ul>
<p>另外还有观察者（Observer）和广播者（Broadcaster），这两种角色不常使用，但也十分有用，例如iBeacon，就可以使用广播者角色来做，只需要广播特定内容即可。 </p>
<ul>
<li>观察者，观察者角色监听空中的广播事件，和主机唯一的区别是不能发起连接，只能持续扫描从机。</li>
<li>广播者，广播者可以持续广播信息，和从机的唯一区别是不能被主机连接，只能广播数据</li>
</ul>
<p>蓝牙协议栈没有限制设备的角色范围，同一个BLE设备，可以作为主机，也可以作为从机，我们称之为主从一体，主从一体的好处是，每个BLE设备都是对等的，可以发起连接，也可以被别人连接，更加实用。 </p>
<h2 id="2-广播"><a href="#2-广播" class="headerlink" title="2.广播"></a>2.广播</h2><p>广播是指从机每经过一个时间间隔发送一次广播数据包，这个时间间隔称为广播间隔，这个广播动作叫做广播事件，只有当从机处于广播状态时，主机才能发现该从机。 在每个广播事件中，广播包会分别在37,38和39三个信道上依次广播，如下图所示。 </p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000025384.png"></p>
<p>广播时间间隔的范围是从20ms到10.24s，广播间隔影响建立连接的时间。广播间隔越大，连接的时间越长。 </p>
<p>另外BLE链路层会在两个广播事件之间添加一个0<del>10ms的随机延时，保证多个设备广播时，不会一直碰撞广播。也就是说，设置100ms的广播间隔，实际上两次广播事件的时间间隔可能是100</del>110ms之间的任意时间。 </p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000027227.png"></p>
<p>广播数据包最多能携带31个字节的数据，一般包含可读的设备名称，设备是否可连接等信息。 </p>
<p>当主机收到从机广播的数据包后，它可以再发送获取更多数据包的请求，这个时候从机将广播扫描回应数据包，扫描回应数据包和广播包一样，可以携带31个字节的数据。 </p>
<p>提示：蓝牙4.x，广播有效载荷最多是31个字节。而在蓝牙5.0中，通过添加额外的广播信道和新的广播PDU，将有效载荷增加到了255个字节</p>
<h2 id="3-扫描"><a href="#3-扫描" class="headerlink" title="3.扫描"></a>3.扫描</h2><p>扫描是主机监听从机广播数据包和发送扫描请求的过程，主机通过扫描，可以获取到从机的广播包以及扫描回应数据包，主机可以对已扫描到的从机设备发起连接请求，从而连接从机设备并通信。 扫描动作有两个比较重要的时间参数：<strong>扫描窗口和扫描间隔</strong>，如果扫描窗口等于扫描间隔，那么主机将一直处于扫描状态之中，持续监听从机广播包。 </p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000029622.jpeg"></p>
<ul>
<li>被动扫描，主机监听广播信道的数据，当接收到广播包时，协议栈将向上层（也就是应用层，用户可编程）传递广播包。</li>
<li>主动扫描，主动扫描除了完成被动扫描的动作外，还会向从机发送一个扫描请求，从机收到该请求时，会再次发送一个称作扫描回应的广播包。</li>
</ul>
<p>所以，主动扫描比被动扫描，可以多收到扫描回应数据包。 </p>
<h2 id="4-连接"><a href="#4-连接" class="headerlink" title="4.连接"></a>4.连接</h2><p>在BLE连接中，使用跳频方案，两个设备在特定时间，特定频道上彼此发送和接收数据。这些设备稍后在新的通道（协议栈链路层处理通道切换）上通过这个约定的时间相遇。这次用于收发数据的相遇被称为<strong>连接事件。<strong>如果没有要发送或接收的应用数据则交换链路层数据来维护连接。两个连接事件之间的事件跨度称为</strong>连接间隔</strong>，是以1.25 ms为单位，范围从最小值7.5 ms到最大值4.0 s  </p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000031483.png"></p>
<p>4.1连接参数</p>
<p><strong>Connection Interval连接间隔</strong>，两次连接事件之间的时间间隔称为连接间隔。1.25 ms为单位，范围从最小值7.5 ms到最大值4.0 s </p>
<p><strong>Slave Latency从机延迟</strong>，如果从机没有要发送的数据，则可以跳过连接事件，继续保持睡眠节省电量。 </p>
<p><strong>Supervision Time-out监控超时</strong>，是两次成功连接事件之间的最长时间。如果在此时间内没有成功的连接事件，设备将终止连接并返回到未连接状态。该参数值以10 ms为单位，监控超时值可以从最小值10（100 ms）到3200（32.0 s）。超时必须大于有效的连接间隔。 </p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000034376.png"></p>
<p>4.2连接参数更新请求</p>
<p>连接参数由主机发起连接的时候提供，如果从机对连接参数有自己的要求，例如要求更低的功耗，或者更高的通信速率等，从机可以向主机发送连接参数更新请求。 </p>
<p>从机可以在连接后的任何时候发起连接参数更新请求，但最好不要在主从建立连接后立刻发起，建议延迟5s左右再发送请求。 </p>
<p>连接参数更新请求可以修改：Connection Interval连接间隔，Slave Latency从机延迟，Supervision Time-out监控超时。 </p>
<p>4.3有效连接间隔</p>
<p>Effective Connection Interval有效连接间隔等于两个连接事件之间的时间跨度，假设从机跳过最大数量的连接事件，且允许从机延迟（如果从机延迟设置为0，则有效连接间隔等于实际连接间隔，）。 </p>
<p>从机延迟表示可以跳过的最大事件数。该数字的范围可以从最小值0（意味着不能跳过连接事件）到最大值499。最大值不能使有效连接间隔（见下列公式）大于16秒。间隔可以使用以下公式计算： </p>
<p>Effective Connection Interval <strong>&#x3D;****(<strong>Connection Interval</strong>)</strong> × **(*<em>1 <strong>+</strong></em><em>[<strong>Slave Latency</strong>])</em>*</p>
<p>Consider the following example**:**</p>
<ul>
<li>Connection Interval**:** 80 <strong>(<strong>100 ms</strong>)</strong></li>
<li>Slave Latency**:** 4</li>
<li>Effective Connection Interval**:<strong><strong>(<strong>100 ms</strong>)</strong> × <strong>(<strong>1 <strong>+</strong> 4</strong>)</strong></strong>&#x3D;** 500 ms</li>
</ul>
<p>当没有数据从从机发送到主机时，从机每500ms一个连接事件交互一次。 </p>
<h2 id="5-通信"><a href="#5-通信" class="headerlink" title="5.通信"></a>5.通信</h2><p>通俗的说，我们将从机具有的数据或者属性特征，称之为Profile，Profile可翻译为：配置文件。 </p>
<p>从机中添加Profile配置文件（定义和存储Profile），作为GATT的Server端，主机作为GATT的Client端</p>
<p>Profile包含一个或者多个Service，每个Servicer又包含一个或者多个的Characteristic。主机可以发现和获取从机的 Service和Characteristic，然后与之通信。Characteristic是主从通信的最小单元。  </p>
<ul>
<li>主机可主动向从机Write写入或Read读取数据。</li>
<li>从机可主动向主机Notify通知数据。</li>
</ul>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000036902.png"></p>
<p>注意，这里引用了<strong>服务 Service 和 特征值 Characteristic</strong> 的概念。每个服务和特征值都有自己的<strong>唯一标识 UUID</strong>，标准UUID为128位，蓝牙协议栈中一般采用16位，也就是两个字节的UUID格式。 </p>
<p>一个从机设备包括一个或者多个服务；一个服务中又可以包括一条或者多条特征值，每个特征值都有自己的<strong>属性 Property</strong>，属性的取值有：<strong>可读 Read</strong>，<strong>可写 Write</strong> 以及 <strong>通知 Notify</strong>。 </p>
<ul>
<li>可读可写的字面意思容易理解，表示该特征值可以被主机读取和写入数据，</li>
<li>而通知则表示从机可以主动向主机发送通知数据。这便是主从机之间两个典型的通信方式。</li>
</ul>
<p>下图是一个典型的从机设备，该从机包含有一个Profile，两个个Service和五个Characteristic。我们先来介绍这些特征值的作用，然后介绍如何通过特征值通信。 </p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000038545.png"></p>
<p><strong>服务0x180A</strong></p>
<p>180A是蓝牙协议里标准的服务UUID，用来描述设备信息Device Information，可以通过该服务来提供从机设备的相关说明，例如硬件版本，软件版本，序列号之类的信息。这样主机就可以获得从机的设备信息。上图中我们添加了三个具体信息的特征值。</p>
<ul>
<li>特征值0x2A24，描述产品型号 Model Number String，例如某智能锁的产品型号为：“DSL-C07”。</li>
<li>特征值0x2A25，描述产品序列号 Serial Number String，例如某智能锁的产品序列号为：“lkjl0016190502500269”</li>
<li>特征值0x2A26，描述产品固件版本号 Firmaware Revision String，例如某智能锁的固件号为：“2.7.2.0”</li>
</ul>
<p>上述特征值仅有Read属性，因此主机只能读，不能执行写操作。 </p>
<p><strong>服务0xFFF0</strong></p>
<p>FFF0是我们自定义的服务UUID，它包含两个特征值，用来发送和接收数据。 </p>
<ul>
<li>特征值0xFFF1，自定义的数据发送通道，具有Read和Write属性，主机可以通过该特征值，向从机发送数据，至于发送的数据最大长度，可以在Profile中配置。</li>
<li>特征值0xFFF2，自定义的数据接收通道，具有Notify属性，从机可以通过该特征值，主动向主机发送数据。</li>
</ul>
<p>假设主机写特征值的协议栈函数原型为 int GATT_WriteCharValue(uuid_t UUID, uint8 *pValue, uint8 len)</p>
<p>假设从机发送通知的协议栈函数原型为 int GATT_Notification(uuid_t UUID, uint8 *pValue, uint8 len)</p>
<p>那么主机向从机发送Hello，可以这样调用协议栈的函数：GATT_WriteCharValue(0xFFF1,”Hello”,5)</p>
<p>那么从机向主机发送1234，可以这样调用协议栈的函数：GATT_Notification(0xFFF2,”1234”,4)</p>
<h2 id="6-主从机交互演示"><a href="#6-主从机交互演示" class="headerlink" title="6.主从机交互演示"></a>6.主从机交互演示</h2><p>6.1上电初始化</p>
<p> 首先进行协议栈初始化和相关功能调用，如下图所示。  </p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000041514.png"></p>
<ul>
<li>主机设备，主机初始化时，需要设置设备类型，设置用于扫描的相关参数，初始化GATT等协议相关的参数。（下一章节详细介绍何为GATT）</li>
<li>从机设备，从机初始化时，需要设置设备名称，广播相关参数，从机Profile等。从机一般会立即开启广播，也可以等待一个事件来触发广播，例如按键触发。</li>
</ul>
<p>6.2主机扫描从机</p>
<p>按键按下，触发主机扫描从机，此时，主机显示屏打印Scanning正在扫描。此刻的从机仍然处于广播状态。</p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000052330.png"></p>
<p>6.2发现从机</p>
<p>当主机扫描到从机时，可以返回已扫描到的从机相关信息，例如可以提取到下图中的从机设备名称，从机MAC地址，从机的RSSI信号值等数据。 </p>
<p>因此，有些应用在从机的广播包或者扫描回应包中添加自定义字段，这样就可以被主机通过扫描的方式拿到数据。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29413051/1673435823175-b30c76c1-9699-4ee2-9e7d-9f22e9937922.png"></p>
<p>6.3发送连接请求</p>
<p>当主机扫描到从机后，通过MAC地址向从机发送连接请求。低功耗蓝牙的连接速度非常快，100ms左右即可成功连接上。如果从机的广播比较大，则会影响连接的速度。 </p>
<p>从机在未收到连接请求之前仍然处于自由的广播状态。</p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000053844.png"></p>
<p>6.4成功连接</p>
<p>当从机收到连接请求后，双方成功建立连接，此时双方的状态均变为已连接状态。 </p>
<p>然后主机可以调用协议栈提供的接口函数来获取从机的服务。</p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000055516.png"></p>
<p>6.5获取从机服务</p>
<p>获取从机服务通常是在连接成功后就立即执行的，因为只有获取从机的服务后，才能与其通信。下图是主机向从机发送获取服务的请求。 </p>
<p>此刻，从机处于已连接状态。响应服务获取请求是在底层自动完成，上层无需理会。</p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000057813.png"></p>
<p>6.6成功获取服务</p>
<p>如下图所示，主机成功获取到从机的服务，例如获取到UUID为0xFFF0的Services，该Service有两个特征值，分别是具有读写属性的0xFFF1，以及具有通知属性的0xFFF2。 </p>
<p>读写属性是指主机可以读写该特征值的内容。而通知属性是指从机可以通过该特征值向主机发送数据。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/29413051/1673436929346-bb8f0c7e-e0f0-41e3-951a-45338ce075fb.png"></p>
<p>6.7主机向从机发送数据</p>
<p>主机通过特征值0xFFF1，主动向从机发送自定义数据Hello，当数据成功发送后，主机状态变为：数据已发送。从机将收到主机发来的数据，从机状态变为收到数据。</p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000100048.png"></p>
<p>6.8从机向主机发送数据</p>
<p>从机可以通过Norify的方式主动向主机发送数据，例如下图，从机通过特征值0xFFF2发送了一条Notify通知，数据内容为：1234</p>
<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000101714.png"></p>
<h1 id="GAP和GATT"><a href="#GAP和GATT" class="headerlink" title="GAP和GATT"></a>GAP和GATT</h1><p>蓝牙协议栈分为两类结构：控制器（Controller）和主机（Host）。每个类别都有子类别，这些子类别执行特定的角色。我们将要研究的两个子类别是  通用访问配置文件  （GAP）和  通用属性配置文件  （GATT）。 </p>
<ul>
<li>GAP是Generic Access Profile的缩写，中文含义是：通用访问配置文件。</li>
<li>GATT是Generic Attribute Profile的缩写，中文含义是：通用属性配置文件。</li>
</ul>
<h3 id="GAP和GATT区别"><a href="#GAP和GATT区别" class="headerlink" title="GAP和GATT区别"></a>GAP和GATT区别</h3><p>BLE（蓝牙低功耗）中的 <strong>GAP</strong>（Generic Access Profile）和 <strong>GATT</strong>（Generic Attribute Profile）是核心协议，分别负责设备连接管理和数据交互。</p>
<h3 id="1-GAP（Generic-Access-Profile）"><a href="#1-GAP（Generic-Access-Profile）" class="headerlink" title="1. GAP（Generic Access Profile）"></a><strong>1. GAP（Generic Access Profile）</strong></h3><p><strong>作用</strong>：管理设备的广播、发现、连接和安全。<br><strong>核心功能</strong>：</p>
<ul>
<li><strong>设备角色定义</strong>：<ul>
<li><strong>外围设备（Peripheral）</strong>：广播自身存在（如传感器、手环）。</li>
<li><strong>中央设备（Central）</strong>：扫描并发起连接（如手机、平板）。</li>
<li><strong>广播者（Broadcaster）</strong>：仅广播数据，不建立连接（如信标）。</li>
<li><strong>观察者（Observer）</strong>：只接收广播，不连接（如扫描设备）。</li>
</ul>
</li>
<li><strong>广播与发现</strong>：<ul>
<li>外围设备通过广播数据包（包含设备名称、服务UUID等）宣告存在。</li>
<li>中央设备扫描广播并选择设备连接。</li>
</ul>
</li>
<li><strong>连接管理</strong>：<ul>
<li>定义连接建立过程（如配对、加密）。</li>
<li>控制连接参数（间隔、延迟等）。</li>
</ul>
</li>
<li><strong>安全控制</strong>：<ul>
<li>设置配对模式（如Just Works、Passkey Entry）。</li>
</ul>
</li>
</ul>
<h3 id="2-GATT（Generic-Attribute-Profile）"><a href="#2-GATT（Generic-Attribute-Profile）" class="headerlink" title="2. GATT（Generic Attribute Profile）"></a><strong>2. GATT（Generic Attribute Profile）</strong></h3><p><strong>作用</strong>：定义连接后的数据交互结构和协议。<br><strong>核心功能</strong>：</p>
<ul>
<li><strong>数据组织结构</strong>：<ul>
<li>数据以 <strong>属性（Attribute）</strong> 形式存储，结构为：<ul>
<li><strong>服务（Service）</strong>：功能集合（如心率服务）。</li>
<li><strong>特征（Characteristic）</strong>：服务中的具体数据（如心率值）。</li>
<li><strong>描述符（Descriptor）</strong>：特征的附加信息（如单位、权限）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>角色定义</strong>：<ul>
<li><strong>服务端（Server）</strong>：存储数据（如手环存储心率数据）。</li>
<li><strong>客户端（Client）</strong>：读写数据（如手机读取心率）。</li>
</ul>
</li>
<li><strong>操作协议</strong>：<ul>
<li>客户端通过 <strong>UUID</strong> 访问服务&#x2F;特征。</li>
<li>支持读写、通知（Notify）、指示（Indicate）等操作。</li>
</ul>
</li>
</ul>
<h3 id="GAP-vs-GATT-关键区别"><a href="#GAP-vs-GATT-关键区别" class="headerlink" title="GAP vs GATT 关键区别"></a><strong>GAP vs GATT 关键区别</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>GAP</th>
<th>GATT</th>
</tr>
</thead>
<tbody><tr>
<td><strong>阶段</strong></td>
<td>连接前（广播、发现、配对）</td>
<td>连接后（数据传输）</td>
</tr>
<tr>
<td><strong>核心任务</strong></td>
<td>设备可见性和连接管理</td>
<td>数据组织与交互</td>
</tr>
<tr>
<td><strong>数据结构</strong></td>
<td>无</td>
<td>服务、特征、描述符的层级结构</td>
</tr>
<tr>
<td><strong>典型操作</strong></td>
<td>广播、扫描、配对</td>
<td>读写、通知、指示</td>
</tr>
</tbody></table>
<h3 id="协作流程示例：以开蓝牙门锁为例-手机是主机-门锁是从机"><a href="#协作流程示例：以开蓝牙门锁为例-手机是主机-门锁是从机" class="headerlink" title="协作流程示例：以开蓝牙门锁为例 手机是主机 门锁是从机"></a>协作流程示例：以开蓝牙门锁为例 手机是主机 门锁是从机</h3><h3 id="1-GAP-层：设备发现与连接"><a href="#1-GAP-层：设备发现与连接" class="headerlink" title="1. GAP 层：设备发现与连接"></a><strong>1. GAP 层：设备发现与连接</strong></h3><h4 id="阶段-1：门锁广播自身存在"><a href="#阶段-1：门锁广播自身存在" class="headerlink" title="阶段 1：门锁广播自身存在"></a><strong>阶段 1：门锁广播自身存在</strong></h4><ul>
<li><strong>门锁（Peripheral）</strong> 通过GAP角色持续广播数据包，包含以下信息：<ul>
<li><strong>广播数据</strong>：设备名称（如 <code>SmartLock-123</code>）、服务UUID（如 <code>0x1810</code> 门锁服务）。</li>
<li><strong>连接参数</strong>：是否允许连接、广播间隔等。</li>
<li><strong>安全标志</strong>：是否需要配对（如MITM保护）。</li>
</ul>
</li>
</ul>
<h4 id="阶段-2：手机扫描并发起连接"><a href="#阶段-2：手机扫描并发起连接" class="headerlink" title="阶段 2：手机扫描并发起连接"></a><strong>阶段 2：手机扫描并发起连接</strong></h4><ul>
<li><strong>手机（Central）</strong> 扫描周围的广播包，识别门锁的广播信息。</li>
<li>用户通过APP选择门锁后，手机向门锁发起连接请求（CONNECT_REQ）。</li>
<li><strong>GAP安全控制</strong>（可选）：<ul>
<li>如果门锁要求配对，手机会弹出配对请求（如输入PIN码或确认Just Works）。</li>
<li>配对成功后生成加密链路（LE Secure Connection）。</li>
</ul>
</li>
</ul>
<h3 id="2-GATT-层：数据交互与开锁指令"><a href="#2-GATT-层：数据交互与开锁指令" class="headerlink" title="2. GATT 层：数据交互与开锁指令"></a><strong>2. GATT 层：数据交互与开锁指令</strong></h3><h4 id="阶段-3：发现门锁的GATT服务"><a href="#阶段-3：发现门锁的GATT服务" class="headerlink" title="阶段 3：发现门锁的GATT服务"></a><strong>阶段 3：发现门锁的GATT服务</strong></h4><ul>
<li>连接建立后，手机（GATT Client）查询门锁（GATT Server）的GATT数据库：<ol>
<li><strong>发现主服务</strong>：手机发送 <code>Discover Primary Services</code> 请求，获取门锁支持的服务列表（如电池服务、门锁控制服务）。</li>
<li><strong>发现特征值</strong>：针对门锁控制服务（如UUID <code>0xA001</code>），手机查询其包含的特征（Characteristics）：<ul>
<li><strong>开锁特征</strong>（UUID <code>0xB001</code>，属性：Write）。</li>
<li><strong>状态特征</strong>（UUID <code>0xB002</code>，属性：Notify，用于反馈锁状态）。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="阶段-4：发送开锁指令"><a href="#阶段-4：发送开锁指令" class="headerlink" title="阶段 4：发送开锁指令"></a><strong>阶段 4：发送开锁指令</strong></h4><ul>
<li>手机向门锁的 <strong>开锁特征</strong>（<code>0xB001</code>）写入指令：<ul>
<li><strong>Write Request</strong>：发送加密的开锁命令（如 <code>0x01</code> 表示开锁）。</li>
<li><strong>门锁响应</strong>：<ul>
<li>若需授权，门锁可能通过GATT要求用户认证（如APP内二次确认）。</li>
<li>门锁执行开锁动作，并通过 <strong>状态特征</strong>（<code>0xB002</code>）发送Notify通知手机（如 <code>0x01</code> 表示已开锁）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-yaml">手机 (Central)                           门锁 (Peripheral)
     |                                       |
     | ←------- ADV Packet (GAP) ----------- |   // 门锁广播
     |                                       |
     | -- SCAN_REQ →                          |   // 手机扫描
     | ←-- SCAN_RSP (设备名称/UUID) -------- |
     |                                       |
     | -- CONNECT_REQ →                       |   // 发起连接
     | ←-- CONNECT_ACK ---------------------- |   // 连接建立
     |                                       |
     | -- Discover Services →                |   // GATT服务发现
     | ←-- 门锁服务UUID列表 ---------------- |
     |                                       |
     | -- Discover Characteristics →         |   // 发现开锁特征
     | ←-- 开锁特征UUID (Write) ------------ |
     |                                       |
     | -- Write Request (0x01) →             |   // 发送开锁指令
     | ←-- Write Response ----------------- |   // 门锁确认
     |                                       |
     | ←-- Notify (锁状态更新) ------------- |   // 可选的状态反馈
</code></pre>
<h3 id="如何伪造主机（手机）与从机（门锁）进行交互？"><a href="#如何伪造主机（手机）与从机（门锁）进行交互？" class="headerlink" title="如何伪造主机（手机）与从机（门锁）进行交互？"></a>如何伪造主机（手机）与从机（门锁）进行交互？</h3><h4 id="前期信息侦察"><a href="#前期信息侦察" class="headerlink" title="前期信息侦察"></a>前期信息侦察</h4><ul>
<li><strong>蓝牙协议版本</strong></li>
<li><strong>GAP 广播数据：</strong> 门锁广播什么信息？例如，设备名称、UUID 等。可以尝试用手机上的 NRFCONNECT 查看门锁的广播信息。</li>
<li><strong>GATT 服务和特征：</strong> 门锁提供了哪些 GATT 服务？哪个服务和特征是用于控制开锁的？你需要知道这些服务的 UUID 和特征的 UUID，以及写入这个特征所需的数据格式（例如，特定的字节序列）。你可以使用支持 GATT 浏览的手机App（例如“nRF Connect for Mobile”、“LightBlue”）连接到门锁，查看它提供的服务和特征。</li>
<li><strong>配对和绑定：</strong> 门锁是否需要配对和绑定才能进行控制？如果需要，需要先完成配对过程。</li>
</ul>
<h4 id="所用工具"><a href="#所用工具" class="headerlink" title="所用工具"></a>所用工具</h4><ul>
<li><strong>BLE嗅探&#x2F;开发硬件</strong>：<ul>
<li><strong>BLE开发板</strong>：如 CC2650、ESP32（支持主从模式）。</li>
<li><strong>嗅探工具</strong>：Ubertooth、nRF Sniffer（配合Wireshark抓包）。</li>
<li><strong>替代方案</strong>：树莓派（安装BlueZ）</li>
</ul>
</li>
<li><strong>软件工具</strong>：<ul>
<li><strong>BLE调试APP</strong>：nRF Connect、LightBlue（用于初步探测）。</li>
<li><strong>开发框架</strong>：<ul>
<li><strong>Android</strong>：Android BLE API（Java&#x2F;Kotlin）。</li>
<li><strong>Linux</strong>：BlueZ库（<code>gatttool</code>、<code>bluetoothctl</code>）。</li>
<li><strong>Python</strong>：<code>pybluez</code>、<code>bleak</code>库。</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 ch0en3&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;ch0en3
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
