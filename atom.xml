<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ch0en3&#39;s blog</title>
  
  <subtitle>当时年少春衫薄</subtitle>
  <link href="https://ch0en3.github.io/atom.xml" rel="self"/>
  
  <link href="https://ch0en3.github.io/"/>
  <updated>2025-04-24T13:25:24.423Z</updated>
  <id>https://ch0en3.github.io/</id>
  
  <author>
    <name>ch0en3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BLE安全学习基础</title>
    <link href="https://ch0en3.github.io/2025/04/BLE%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <id>https://ch0en3.github.io/2025/04/BLE%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</id>
    <published>2025-04-23T16:00:00.000Z</published>
    <updated>2025-04-24T13:25:24.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议栈基础介绍"><a href="#协议栈基础介绍" class="headerlink" title="协议栈基础介绍"></a>协议栈基础介绍</h1><p>一个BLE应用首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后基于协议栈开发自己的应用。BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。BLE协议栈主要用来对你的应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。 </p><p>蓝牙协议规定了两个层次的协议，分别为蓝牙核心协议（Bluetooth Core）和蓝牙应用层协议（Bluetooth Application）。蓝牙核心协议关注对蓝牙核心技术的描述和规范，它只提供基础的机制，并不关心如何使用这些机制；蓝牙应用层协议，是在蓝牙核心协议的基础上，根据具体的应用需求，百花齐放，定义出各种各样的策略，如FTP、文件传输、局域网等等。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000016846.png"></p><p> 蓝牙核心协议（Bluetooth Core）又包含BLE Controller和BLE Host两部分。这两部分在不同的蓝牙技术中（BR&#x2F;EDR、AMP、LE），承担角色略有不同，但大致的功能是相同的。Controller负责定义RF、Baseband等偏硬件的规范，并在这之上抽象出用于通信的逻辑链路（Logical Link）；Host负责在逻辑链路的基础上，进行更为友好的封装，这样就可以屏蔽掉蓝牙技术的细节，让Bluetooth Application更为方便的使用。  </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000017104.jpeg" alt="画板"></p><p><strong>BLE低功耗蓝牙核心协议层详解（Bluetooth Core）</strong></p><p>**物理层（Physical Layer，简写 PHY）：**PHY用来指定BLE所用的无线频段，调制解调方式和方法等。例如是1Mbps自适应跳频的GFSK射频，工作于免许可证的2.4GHz ISM（工业、科学与医疗）频段。   PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。  </p><p><strong>链路层（Link Layer，简写 LL）:LL是BLE协议栈的核心。LL要层要做的事情很多，</strong> 比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者GATT。</p><p><strong>主机控制接口层（Host Controller Interface，简写 HCI）</strong>：HCI是可选的，HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。  </p><p>**通用访问配置文件层（Generic access profile，简写GAP）：**GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且只有简单的那一种，GAP简单的对LL的payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。</p><p><strong>逻辑链路控制及自适应协议层（Logical Link Control and Adaptation Protocol，简写 L2CAP）：L2CAP对LL惊醒了一次简单封装，LL只关心传输的数据本身，L2CAP就是要区分是加密通道还是普通通道，同时还对连接间隔进行管理。</strong></p><p><strong>安全管理层（Security Manager，简写 SM）：SM用来管理BLE连接的加密和安全。入和保证连接的安全性同时不影响用户的体验这些都是SMP要考虑的工作</strong></p><p><strong>属性协议层（Attribute protocol，简写 ATT）:ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE引用了attribute概念用来描述一条条的数据。attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层</strong></p><p><strong>通用属性配置文件层（Generic Attribute profile，简写 GATT）</strong>：  GATT用来规范attribute中的数据内容并运用group(分组)的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但是互联互通就会出现问题</p><h1 id="BLE协议栈如何完成发送任务"><a href="#BLE协议栈如何完成发送任务" class="headerlink" title="BLE协议栈如何完成发送任务"></a>BLE协议栈如何完成发送任务</h1><p>假设存在设备A和设备B， 设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B 。对于开发者来说这个过程越简单越好，最好是直接调用一个API就行， 比如send(0x53)，实际上我们的BLE协议栈就是这样设计的，开发者只需调用send(0x53)就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去，就如下图所示：  </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000014137.png"></p><p>但是这种方式实际是不可行的。首先它没有考虑使用哪个射频信道进行传输，不更改API的情况下我们只能对协议栈进行分层，为此引入LL层，开发者还是调用send(0x53)，send(0x53)再调用send_LL(0x53,2402M) 。 这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入<strong>access address概念，用来指明接收者身份</strong>，其中，<strong>0x8E89BED6</strong>这个access address比较特殊，它表示要发给周边所有设备，即广播。如果你要一对一的进行通信（BLE协议将其称为<strong>连接</strong>），即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须生成一个独特的<strong>随机</strong>access address以标识设备A和设备B两者之间的连接。  </p><h2 id="广播方式"><a href="#广播方式" class="headerlink" title="广播方式"></a>广播方式</h2><p>假设设备A为<strong>advertiser</strong>（广播者） ， 设备B叫<strong>scanner</strong>或者<strong>observer</strong>（扫描者）。 广播状态下设备A的LL层API将变成send_LL(<strong>0x53,2402M</strong>, <strong>0x8E89BED6</strong>)  。 由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的device address（<strong>0xE1022AAB753B</strong>）以确认该广播包来自设备A，为此send_LL参数需要变成(<strong>0x53,2402M</strong>, <strong>0x8E89BED6</strong>, <strong>0xE1022AAB753B</strong>)。  LL层还要检查设备的完整性， 即数据在传输过程中有没有发生窜改，为此引入<strong>CRC24</strong>对数据包进行检验 (假设为<strong>0xB2C78E</strong>) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble（前导帧），preamble一般为<strong>0x55</strong>或者<strong>0xAA</strong>。这样，整个空中包就变成（注：<strong>空中包用小端模式表示（小端模式低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。）</strong>）：  </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424151358602.png"></p><p>上面这个数据包还有如下问题：</p><ul><li>没有对数据包进行分类组织，设备B无法找到自己想要的数据0x53。为此我们需要在access address之后加入两个字段：LL header和长度字节。LL header用来表示数据包的LL类型，长度字节用来指明payload的长度  </li><li>设备B什么时候开启射频窗口以接收空中数据包？如上图case1所示，当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；同样对case2来说，当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有case3的情况，通信才能成功，即设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，<strong>LL层还必须定义通信时序</strong>。</li><li>当设备B拿到数据0x53后，该如何解析这个数据呢？它到底表示湿度还是电量，还是别的意思？这个就是GAP层要做的工作。 <strong>GAP层引入了LTV（Length-Type-Value）结构来定义数据</strong>，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值 。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。  </li><li>最终空中传输的数据包将变成：</li><li>AAD6BE898E600E3B75AB2A02E102010504FF5900<strong>53</strong>8EC7B2 <ul><li>AA – 前导帧(preamble)</li><li>D6BE898E – 访问地址(access address)</li><li>60 – LL帧头字段(LL header)</li><li>0E – 有效数据包长度(payload length)</li><li>3B75AB2A02E1 – 广播者设备地址(advertiser address)</li><li>02010504FF5900**53 – **<strong>广播数据</strong></li><li>8EC7B2 – CRC24值</li><li><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000020838.png"></li></ul></li></ul><p>有了PHY,LL，和GAP就可以发送广播包了，但是还是会有几个限制</p><ul><li>1.无法进行一对一双向通信（广播是一对多通信，而且是单方向的）</li><li>不支持组包和拆包，无法传输大数据</li><li>通信不可靠且效率低下。广播信道不能太多否则导致扫描段效率低下。为此 BLE只使用37(2402MHz) &#x2F;38(2426MHz) &#x2F;39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。  </li><li>扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37&#x2F;38&#x2F;39三个通道进行扫描，这样功耗就会比较高。</li></ul><p>而连接可以解决以上问题。</p><h2 id="BLE连接方式"><a href="#BLE连接方式" class="headerlink" title="BLE连接方式"></a>BLE连接方式</h2><p>什么叫连接？像UART很容易理解，用线（rx和tx等）把设备A和设备B相连，就叫做连接。所谓设备A和设备B建立蓝牙连接就是指两个设备一对一同步成功，其具体包含一下几个方面</p><ol><li>设备A和B对接下来使用的物理信道一致</li><li>设备A和设备B双方建立一个共同的时间锚点，也就是说把双方的时间原点变成同一个点</li><li>设备A和B两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包</li><li>连接成功后，设备A和B通信流程如图所示</li><li><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000022937.png"></li></ol><p>如图所示， 一旦设备A和设备B连接成功（此种情况下，我们把设备A称为<strong>Master</strong>或者<strong>Central</strong>，把设备B称为<strong>Slave</strong>或者<strong>Peripheral</strong>） ，设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包。  同时按照蓝牙spec要求，设备B收到设备A数据包150us后设备B切换发送状态把自己的数据发给设备A；设备A则切换到接收状态接收设备B发过来的数据。可以看到连接状态下设备A和B的射频发送和接收窗口都是周期性的有计划的开和关并且开的时间非常短从而大大降低设备功率</p><ul><li>对开发者来说，很简单，他只需要调用send(0x53)</li><li>GATT层定义数据的类型和分组，方便起见，我们用0x0013标识电量这种数据类型，这样GATT层把数据打包成130053（小端模式）</li><li>ATT层用来选择具体的通信命令，比如读写 比如读&#x2F;写&#x2F;notify&#x2F;indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053  </li><li>L2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053</li><li>LL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个**Access address（0x50655DAB）**以标识此连接只为设备A 和设备B 直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：</li></ul><p>o  AAAB5D65501E08040004001B130053D550F6    </p><p> o  AA – 前导帧(preamble)  </p><p> o  0x50655DAB – 访问地址(access address)  </p><p> o  1E – LL帧头字段(LL header)  </p><p> o  08 – 有效数据包长度(payload length)</p><p> o  04000400 – ATT数据长度，以及L2CAP通道编号</p><p>  o  1B – notify command</p><p>o  0x0013 – 电量数据handle</p><p> o  0x53 – 真正要发送的电量数据</p><p> o  0xF650D5 – CRC24值</p><h1 id="BLE工作流程"><a href="#BLE工作流程" class="headerlink" title="BLE工作流程"></a>BLE工作流程</h1><h2 id="1-角色"><a href="#1-角色" class="headerlink" title="1.角色"></a>1.角色</h2><p>BLE设备角色主要分为两种角色，主机（Master或Central）和从机（Peripheral），当主机和从机建立连接之后才能相互收发数据 </p><ul><li>主机，主机可以发起对从机的扫描连接。例如手机，通常作为BLE的主机设备</li><li>从机，从机只能广播并等待主机的连接。例如智能手环，是作为BLE的从机设备</li></ul><p>另外还有观察者（Observer）和广播者（Broadcaster），这两种角色不常使用，但也十分有用，例如iBeacon，就可以使用广播者角色来做，只需要广播特定内容即可。 </p><ul><li>观察者，观察者角色监听空中的广播事件，和主机唯一的区别是不能发起连接，只能持续扫描从机。</li><li>广播者，广播者可以持续广播信息，和从机的唯一区别是不能被主机连接，只能广播数据</li></ul><p>蓝牙协议栈没有限制设备的角色范围，同一个BLE设备，可以作为主机，也可以作为从机，我们称之为主从一体，主从一体的好处是，每个BLE设备都是对等的，可以发起连接，也可以被别人连接，更加实用。 </p><h2 id="2-广播"><a href="#2-广播" class="headerlink" title="2.广播"></a>2.广播</h2><p>广播是指从机每经过一个时间间隔发送一次广播数据包，这个时间间隔称为广播间隔，这个广播动作叫做广播事件，只有当从机处于广播状态时，主机才能发现该从机。 在每个广播事件中，广播包会分别在37,38和39三个信道上依次广播，如下图所示。 </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000025384.png"></p><p>广播时间间隔的范围是从20ms到10.24s，广播间隔影响建立连接的时间。广播间隔越大，连接的时间越长。 </p><p>另外BLE链路层会在两个广播事件之间添加一个0<del>10ms的随机延时，保证多个设备广播时，不会一直碰撞广播。也就是说，设置100ms的广播间隔，实际上两次广播事件的时间间隔可能是100</del>110ms之间的任意时间。 </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000027227.png"></p><p>广播数据包最多能携带31个字节的数据，一般包含可读的设备名称，设备是否可连接等信息。 </p><p>当主机收到从机广播的数据包后，它可以再发送获取更多数据包的请求，这个时候从机将广播扫描回应数据包，扫描回应数据包和广播包一样，可以携带31个字节的数据。 </p><p>提示：蓝牙4.x，广播有效载荷最多是31个字节。而在蓝牙5.0中，通过添加额外的广播信道和新的广播PDU，将有效载荷增加到了255个字节</p><h2 id="3-扫描"><a href="#3-扫描" class="headerlink" title="3.扫描"></a>3.扫描</h2><p>扫描是主机监听从机广播数据包和发送扫描请求的过程，主机通过扫描，可以获取到从机的广播包以及扫描回应数据包，主机可以对已扫描到的从机设备发起连接请求，从而连接从机设备并通信。 扫描动作有两个比较重要的时间参数：<strong>扫描窗口和扫描间隔</strong>，如果扫描窗口等于扫描间隔，那么主机将一直处于扫描状态之中，持续监听从机广播包。 </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000029622.jpeg"></p><ul><li>被动扫描，主机监听广播信道的数据，当接收到广播包时，协议栈将向上层（也就是应用层，用户可编程）传递广播包。</li><li>主动扫描，主动扫描除了完成被动扫描的动作外，还会向从机发送一个扫描请求，从机收到该请求时，会再次发送一个称作扫描回应的广播包。</li></ul><p>所以，主动扫描比被动扫描，可以多收到扫描回应数据包。 </p><h2 id="4-连接"><a href="#4-连接" class="headerlink" title="4.连接"></a>4.连接</h2><p>在BLE连接中，使用跳频方案，两个设备在特定时间，特定频道上彼此发送和接收数据。这些设备稍后在新的通道（协议栈链路层处理通道切换）上通过这个约定的时间相遇。这次用于收发数据的相遇被称为<strong>连接事件。<strong>如果没有要发送或接收的应用数据则交换链路层数据来维护连接。两个连接事件之间的事件跨度称为</strong>连接间隔</strong>，是以1.25 ms为单位，范围从最小值7.5 ms到最大值4.0 s  </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000031483.png"></p><p>4.1连接参数</p><p><strong>Connection Interval连接间隔</strong>，两次连接事件之间的时间间隔称为连接间隔。1.25 ms为单位，范围从最小值7.5 ms到最大值4.0 s </p><p><strong>Slave Latency从机延迟</strong>，如果从机没有要发送的数据，则可以跳过连接事件，继续保持睡眠节省电量。 </p><p><strong>Supervision Time-out监控超时</strong>，是两次成功连接事件之间的最长时间。如果在此时间内没有成功的连接事件，设备将终止连接并返回到未连接状态。该参数值以10 ms为单位，监控超时值可以从最小值10（100 ms）到3200（32.0 s）。超时必须大于有效的连接间隔。 </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000034376.png"></p><p>4.2连接参数更新请求</p><p>连接参数由主机发起连接的时候提供，如果从机对连接参数有自己的要求，例如要求更低的功耗，或者更高的通信速率等，从机可以向主机发送连接参数更新请求。 </p><p>从机可以在连接后的任何时候发起连接参数更新请求，但最好不要在主从建立连接后立刻发起，建议延迟5s左右再发送请求。 </p><p>连接参数更新请求可以修改：Connection Interval连接间隔，Slave Latency从机延迟，Supervision Time-out监控超时。 </p><p>4.3有效连接间隔</p><p>Effective Connection Interval有效连接间隔等于两个连接事件之间的时间跨度，假设从机跳过最大数量的连接事件，且允许从机延迟（如果从机延迟设置为0，则有效连接间隔等于实际连接间隔，）。 </p><p>从机延迟表示可以跳过的最大事件数。该数字的范围可以从最小值0（意味着不能跳过连接事件）到最大值499。最大值不能使有效连接间隔（见下列公式）大于16秒。间隔可以使用以下公式计算： </p><p>Effective Connection Interval <strong>&#x3D;****(<strong>Connection Interval</strong>)</strong> × **(*<em>1 <strong>+</strong></em><em>[<strong>Slave Latency</strong>])</em>*</p><p>Consider the following example**:**</p><ul><li>Connection Interval**:** 80 <strong>(<strong>100 ms</strong>)</strong></li><li>Slave Latency**:** 4</li><li>Effective Connection Interval**:<strong><strong>(<strong>100 ms</strong>)</strong> × <strong>(<strong>1 <strong>+</strong> 4</strong>)</strong></strong>&#x3D;** 500 ms</li></ul><p>当没有数据从从机发送到主机时，从机每500ms一个连接事件交互一次。 </p><h2 id="5-通信"><a href="#5-通信" class="headerlink" title="5.通信"></a>5.通信</h2><p>通俗的说，我们将从机具有的数据或者属性特征，称之为Profile，Profile可翻译为：配置文件。 </p><p>从机中添加Profile配置文件（定义和存储Profile），作为GATT的Server端，主机作为GATT的Client端</p><p>Profile包含一个或者多个Service，每个Servicer又包含一个或者多个的Characteristic。主机可以发现和获取从机的 Service和Characteristic，然后与之通信。Characteristic是主从通信的最小单元。  </p><ul><li>主机可主动向从机Write写入或Read读取数据。</li><li>从机可主动向主机Notify通知数据。</li></ul><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000036902.png"></p><p>注意，这里引用了<strong>服务 Service 和 特征值 Characteristic</strong> 的概念。每个服务和特征值都有自己的<strong>唯一标识 UUID</strong>，标准UUID为128位，蓝牙协议栈中一般采用16位，也就是两个字节的UUID格式。 </p><p>一个从机设备包括一个或者多个服务；一个服务中又可以包括一条或者多条特征值，每个特征值都有自己的<strong>属性 Property</strong>，属性的取值有：<strong>可读 Read</strong>，<strong>可写 Write</strong> 以及 <strong>通知 Notify</strong>。 </p><ul><li>可读可写的字面意思容易理解，表示该特征值可以被主机读取和写入数据，</li><li>而通知则表示从机可以主动向主机发送通知数据。这便是主从机之间两个典型的通信方式。</li></ul><p>下图是一个典型的从机设备，该从机包含有一个Profile，两个个Service和五个Characteristic。我们先来介绍这些特征值的作用，然后介绍如何通过特征值通信。 </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000038545.png"></p><p><strong>服务0x180A</strong></p><p>180A是蓝牙协议里标准的服务UUID，用来描述设备信息Device Information，可以通过该服务来提供从机设备的相关说明，例如硬件版本，软件版本，序列号之类的信息。这样主机就可以获得从机的设备信息。上图中我们添加了三个具体信息的特征值。</p><ul><li>特征值0x2A24，描述产品型号 Model Number String，例如某智能锁的产品型号为：“DSL-C07”。</li><li>特征值0x2A25，描述产品序列号 Serial Number String，例如某智能锁的产品序列号为：“lkjl0016190502500269”</li><li>特征值0x2A26，描述产品固件版本号 Firmaware Revision String，例如某智能锁的固件号为：“2.7.2.0”</li></ul><p>上述特征值仅有Read属性，因此主机只能读，不能执行写操作。 </p><p><strong>服务0xFFF0</strong></p><p>FFF0是我们自定义的服务UUID，它包含两个特征值，用来发送和接收数据。 </p><ul><li>特征值0xFFF1，自定义的数据发送通道，具有Read和Write属性，主机可以通过该特征值，向从机发送数据，至于发送的数据最大长度，可以在Profile中配置。</li><li>特征值0xFFF2，自定义的数据接收通道，具有Notify属性，从机可以通过该特征值，主动向主机发送数据。</li></ul><p>假设主机写特征值的协议栈函数原型为 int GATT_WriteCharValue(uuid_t UUID, uint8 *pValue, uint8 len)</p><p>假设从机发送通知的协议栈函数原型为 int GATT_Notification(uuid_t UUID, uint8 *pValue, uint8 len)</p><p>那么主机向从机发送Hello，可以这样调用协议栈的函数：GATT_WriteCharValue(0xFFF1,”Hello”,5)</p><p>那么从机向主机发送1234，可以这样调用协议栈的函数：GATT_Notification(0xFFF2,”1234”,4)</p><h2 id="6-主从机交互演示"><a href="#6-主从机交互演示" class="headerlink" title="6.主从机交互演示"></a>6.主从机交互演示</h2><p>6.1上电初始化</p><p> 首先进行协议栈初始化和相关功能调用，如下图所示。  </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000041514.png"></p><ul><li>主机设备，主机初始化时，需要设置设备类型，设置用于扫描的相关参数，初始化GATT等协议相关的参数。（下一章节详细介绍何为GATT）</li><li>从机设备，从机初始化时，需要设置设备名称，广播相关参数，从机Profile等。从机一般会立即开启广播，也可以等待一个事件来触发广播，例如按键触发。</li></ul><p>6.2主机扫描从机</p><p>按键按下，触发主机扫描从机，此时，主机显示屏打印Scanning正在扫描。此刻的从机仍然处于广播状态。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000052330.png"></p><p>6.2发现从机</p><p>当主机扫描到从机时，可以返回已扫描到的从机相关信息，例如可以提取到下图中的从机设备名称，从机MAC地址，从机的RSSI信号值等数据。 </p><p>因此，有些应用在从机的广播包或者扫描回应包中添加自定义字段，这样就可以被主机通过扫描的方式拿到数据。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424212522617.png"></p><p>6.3发送连接请求</p><p>当主机扫描到从机后，通过MAC地址向从机发送连接请求。低功耗蓝牙的连接速度非常快，100ms左右即可成功连接上。如果从机的广播比较大，则会影响连接的速度。 </p><p>从机在未收到连接请求之前仍然处于自由的广播状态。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000053844.png"></p><p>6.4成功连接</p><p>当从机收到连接请求后，双方成功建立连接，此时双方的状态均变为已连接状态。 </p><p>然后主机可以调用协议栈提供的接口函数来获取从机的服务。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000055516.png"></p><p>6.5获取从机服务</p><p>获取从机服务通常是在连接成功后就立即执行的，因为只有获取从机的服务后，才能与其通信。下图是主机向从机发送获取服务的请求。 </p><p>此刻，从机处于已连接状态。响应服务获取请求是在底层自动完成，上层无需理会。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000057813.png"></p><p>6.6成功获取服务</p><p>如下图所示，主机成功获取到从机的服务，例如获取到UUID为0xFFF0的Services，该Service有两个特征值，分别是具有读写属性的0xFFF1，以及具有通知属性的0xFFF2。 </p><p>读写属性是指主机可以读写该特征值的内容。而通知属性是指从机可以通过该特征值向主机发送数据。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29413051/1673436929346-bb8f0c7e-e0f0-41e3-951a-45338ce075fb.png"></p><p>6.7主机向从机发送数据</p><p>主机通过特征值0xFFF1，主动向从机发送自定义数据Hello，当数据成功发送后，主机状态变为：数据已发送。从机将收到主机发来的数据，从机状态变为收到数据。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000100048.png"></p><p>6.8从机向主机发送数据</p><p>从机可以通过Norify的方式主动向主机发送数据，例如下图，从机通过特征值0xFFF2发送了一条Notify通知，数据内容为：1234</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250424000101714.png"></p><h1 id="GAP和GATT"><a href="#GAP和GATT" class="headerlink" title="GAP和GATT"></a>GAP和GATT</h1><p>蓝牙协议栈分为两类结构：控制器（Controller）和主机（Host）。每个类别都有子类别，这些子类别执行特定的角色。我们将要研究的两个子类别是  通用访问配置文件  （GAP）和  通用属性配置文件  （GATT）。 </p><ul><li>GAP是Generic Access Profile的缩写，中文含义是：通用访问配置文件。</li><li>GATT是Generic Attribute Profile的缩写，中文含义是：通用属性配置文件。</li></ul><h3 id="GAP和GATT区别"><a href="#GAP和GATT区别" class="headerlink" title="GAP和GATT区别"></a>GAP和GATT区别</h3><p>BLE（蓝牙低功耗）中的 <strong>GAP</strong>（Generic Access Profile）和 <strong>GATT</strong>（Generic Attribute Profile）是核心协议，分别负责设备连接管理和数据交互。</p><h3 id="1-GAP（Generic-Access-Profile）"><a href="#1-GAP（Generic-Access-Profile）" class="headerlink" title="1. GAP（Generic Access Profile）"></a><strong>1. GAP（Generic Access Profile）</strong></h3><p><strong>作用</strong>：管理设备的广播、发现、连接和安全。<br><strong>核心功能</strong>：</p><ul><li><strong>设备角色定义</strong>：<ul><li><strong>外围设备（Peripheral）</strong>：广播自身存在（如传感器、手环）。</li><li><strong>中央设备（Central）</strong>：扫描并发起连接（如手机、平板）。</li><li><strong>广播者（Broadcaster）</strong>：仅广播数据，不建立连接（如信标）。</li><li><strong>观察者（Observer）</strong>：只接收广播，不连接（如扫描设备）。</li></ul></li><li><strong>广播与发现</strong>：<ul><li>外围设备通过广播数据包（包含设备名称、服务UUID等）宣告存在。</li><li>中央设备扫描广播并选择设备连接。</li></ul></li><li><strong>连接管理</strong>：<ul><li>定义连接建立过程（如配对、加密）。</li><li>控制连接参数（间隔、延迟等）。</li></ul></li><li><strong>安全控制</strong>：<ul><li>设置配对模式（如Just Works、Passkey Entry）。</li></ul></li></ul><h3 id="2-GATT（Generic-Attribute-Profile）"><a href="#2-GATT（Generic-Attribute-Profile）" class="headerlink" title="2. GATT（Generic Attribute Profile）"></a><strong>2. GATT（Generic Attribute Profile）</strong></h3><p><strong>作用</strong>：定义连接后的数据交互结构和协议。<br><strong>核心功能</strong>：</p><ul><li><strong>数据组织结构</strong>：<ul><li>数据以 <strong>属性（Attribute）</strong> 形式存储，结构为：<ul><li><strong>服务（Service）</strong>：功能集合（如心率服务）。</li><li><strong>特征（Characteristic）</strong>：服务中的具体数据（如心率值）。</li><li><strong>描述符（Descriptor）</strong>：特征的附加信息（如单位、权限）。</li></ul></li></ul></li><li><strong>角色定义</strong>：<ul><li><strong>服务端（Server）</strong>：存储数据（如手环存储心率数据）。</li><li><strong>客户端（Client）</strong>：读写数据（如手机读取心率）。</li></ul></li><li><strong>操作协议</strong>：<ul><li>客户端通过 <strong>UUID</strong> 访问服务&#x2F;特征。</li><li>支持读写、通知（Notify）、指示（Indicate）等操作。</li></ul></li></ul><h3 id="GAP-vs-GATT-关键区别"><a href="#GAP-vs-GATT-关键区别" class="headerlink" title="GAP vs GATT 关键区别"></a><strong>GAP vs GATT 关键区别</strong></h3><table><thead><tr><th>特性</th><th>GAP</th><th>GATT</th></tr></thead><tbody><tr><td><strong>阶段</strong></td><td>连接前（广播、发现、配对）</td><td>连接后（数据传输）</td></tr><tr><td><strong>核心任务</strong></td><td>设备可见性和连接管理</td><td>数据组织与交互</td></tr><tr><td><strong>数据结构</strong></td><td>无</td><td>服务、特征、描述符的层级结构</td></tr><tr><td><strong>典型操作</strong></td><td>广播、扫描、配对</td><td>读写、通知、指示</td></tr></tbody></table><h3 id="协作流程示例：以开蓝牙门锁为例-手机是主机-门锁是从机"><a href="#协作流程示例：以开蓝牙门锁为例-手机是主机-门锁是从机" class="headerlink" title="协作流程示例：以开蓝牙门锁为例 手机是主机 门锁是从机"></a>协作流程示例：以开蓝牙门锁为例 手机是主机 门锁是从机</h3><h3 id="1-GAP-层：设备发现与连接"><a href="#1-GAP-层：设备发现与连接" class="headerlink" title="1. GAP 层：设备发现与连接"></a><strong>1. GAP 层：设备发现与连接</strong></h3><h4 id="阶段-1：门锁广播自身存在"><a href="#阶段-1：门锁广播自身存在" class="headerlink" title="阶段 1：门锁广播自身存在"></a><strong>阶段 1：门锁广播自身存在</strong></h4><ul><li><strong>门锁（Peripheral）</strong> 通过GAP角色持续广播数据包，包含以下信息：<ul><li><strong>广播数据</strong>：设备名称（如 <code>SmartLock-123</code>）、服务UUID（如 <code>0x1810</code> 门锁服务）。</li><li><strong>连接参数</strong>：是否允许连接、广播间隔等。</li><li><strong>安全标志</strong>：是否需要配对（如MITM保护）。</li></ul></li></ul><h4 id="阶段-2：手机扫描并发起连接"><a href="#阶段-2：手机扫描并发起连接" class="headerlink" title="阶段 2：手机扫描并发起连接"></a><strong>阶段 2：手机扫描并发起连接</strong></h4><ul><li><strong>手机（Central）</strong> 扫描周围的广播包，识别门锁的广播信息。</li><li>用户通过APP选择门锁后，手机向门锁发起连接请求（CONNECT_REQ）。</li><li><strong>GAP安全控制</strong>（可选）：<ul><li>如果门锁要求配对，手机会弹出配对请求（如输入PIN码或确认Just Works）。</li><li>配对成功后生成加密链路（LE Secure Connection）。</li></ul></li></ul><h3 id="2-GATT-层：数据交互与开锁指令"><a href="#2-GATT-层：数据交互与开锁指令" class="headerlink" title="2. GATT 层：数据交互与开锁指令"></a><strong>2. GATT 层：数据交互与开锁指令</strong></h3><h4 id="阶段-3：发现门锁的GATT服务"><a href="#阶段-3：发现门锁的GATT服务" class="headerlink" title="阶段 3：发现门锁的GATT服务"></a><strong>阶段 3：发现门锁的GATT服务</strong></h4><ul><li>连接建立后，手机（GATT Client）查询门锁（GATT Server）的GATT数据库：<ol><li><strong>发现主服务</strong>：手机发送 <code>Discover Primary Services</code> 请求，获取门锁支持的服务列表（如电池服务、门锁控制服务）。</li><li><strong>发现特征值</strong>：针对门锁控制服务（如UUID <code>0xA001</code>），手机查询其包含的特征（Characteristics）：<ul><li><strong>开锁特征</strong>（UUID <code>0xB001</code>，属性：Write）。</li><li><strong>状态特征</strong>（UUID <code>0xB002</code>，属性：Notify，用于反馈锁状态）。</li></ul></li></ol></li></ul><h4 id="阶段-4：发送开锁指令"><a href="#阶段-4：发送开锁指令" class="headerlink" title="阶段 4：发送开锁指令"></a><strong>阶段 4：发送开锁指令</strong></h4><ul><li>手机向门锁的 <strong>开锁特征</strong>（<code>0xB001</code>）写入指令：<ul><li><strong>Write Request</strong>：发送加密的开锁命令（如 <code>0x01</code> 表示开锁）。</li><li><strong>门锁响应</strong>：<ul><li>若需授权，门锁可能通过GATT要求用户认证（如APP内二次确认）。</li><li>门锁执行开锁动作，并通过 <strong>状态特征</strong>（<code>0xB002</code>）发送Notify通知手机（如 <code>0x01</code> 表示已开锁）。</li></ul></li></ul></li></ul><pre><code class="language-yaml">手机 (Central)                           门锁 (Peripheral)     |                                       |     | ←------- ADV Packet (GAP) ----------- |   // 门锁广播     |                                       |     | -- SCAN_REQ →                          |   // 手机扫描     | ←-- SCAN_RSP (设备名称/UUID) -------- |     |                                       |     | -- CONNECT_REQ →                       |   // 发起连接     | ←-- CONNECT_ACK ---------------------- |   // 连接建立     |                                       |     | -- Discover Services →                |   // GATT服务发现     | ←-- 门锁服务UUID列表 ---------------- |     |                                       |     | -- Discover Characteristics →         |   // 发现开锁特征     | ←-- 开锁特征UUID (Write) ------------ |     |                                       |     | -- Write Request (0x01) →             |   // 发送开锁指令     | ←-- Write Response ----------------- |   // 门锁确认     |                                       |     | ←-- Notify (锁状态更新) ------------- |   // 可选的状态反馈</code></pre><h3 id="如何伪造主机（手机）与从机（门锁）进行交互？"><a href="#如何伪造主机（手机）与从机（门锁）进行交互？" class="headerlink" title="如何伪造主机（手机）与从机（门锁）进行交互？"></a>如何伪造主机（手机）与从机（门锁）进行交互？</h3><h4 id="前期信息侦察"><a href="#前期信息侦察" class="headerlink" title="前期信息侦察"></a>前期信息侦察</h4><ul><li><strong>蓝牙协议版本</strong></li><li><strong>GAP 广播数据：</strong> 门锁广播什么信息？例如，设备名称、UUID 等。可以尝试用手机上的 NRFCONNECT 查看门锁的广播信息。</li><li><strong>GATT 服务和特征：</strong> 门锁提供了哪些 GATT 服务？哪个服务和特征是用于控制开锁的？你需要知道这些服务的 UUID 和特征的 UUID，以及写入这个特征所需的数据格式（例如，特定的字节序列）。你可以使用支持 GATT 浏览的手机App（例如“nRF Connect for Mobile”、“LightBlue”）连接到门锁，查看它提供的服务和特征。</li><li><strong>配对和绑定：</strong> 门锁是否需要配对和绑定才能进行控制？如果需要，需要先完成配对过程。</li></ul><h4 id="所用工具"><a href="#所用工具" class="headerlink" title="所用工具"></a>所用工具</h4><ul><li><strong>BLE嗅探&#x2F;开发硬件</strong>：<ul><li><strong>BLE开发板</strong>：如 CC2650、ESP32（支持主从模式）。</li><li><strong>嗅探工具</strong>：Ubertooth、nRF Sniffer（配合Wireshark抓包）。</li><li><strong>替代方案</strong>：树莓派（安装BlueZ）</li></ul></li><li><strong>软件工具</strong>：<ul><li><strong>BLE调试APP</strong>：nRF Connect、LightBlue（用于初步探测）。</li><li><strong>开发框架</strong>：<ul><li><strong>Android</strong>：Android BLE API（Java&#x2F;Kotlin）。</li><li><strong>Linux</strong>：BlueZ库（<code>gatttool</code>、<code>bluetoothctl</code>）。</li><li><strong>Python</strong>：<code>pybluez</code>、<code>bleak</code>库。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">BLE安全学习基础
</summary>
    
    
    
    <category term="bluetooth" scheme="https://ch0en3.github.io/categories/bluetooth/"/>
    
    
    <category term="bluetooth" scheme="https://ch0en3.github.io/tags/bluetooth/"/>
    
  </entry>
  
  <entry>
    <title>使用Tcpdump对手机app抓包</title>
    <link href="https://ch0en3.github.io/2025/04/%E4%BD%BF%E7%94%A8tcpdump%E5%AF%B9%E6%89%8B%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85/"/>
    <id>https://ch0en3.github.io/2025/04/%E4%BD%BF%E7%94%A8tcpdump%E5%AF%B9%E6%89%8B%E6%9C%BA%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85/</id>
    <published>2025-04-20T15:24:07.022Z</published>
    <updated>2025-04-20T15:35:26.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h1><p>adb<a href="https://developer.android.google.cn/tools/releases/platform-tools?hl=en">https://developer.android.google.cn/tools/releases/platform-tools?hl=en</a></p><p> tcpdump <a href="https://www.androidtcpdump.com/android-tcpdump/downloads64bit">https://www.androidtcpdump.com/android-tcpdump/downloads64bit</a></p><h1 id="tcpdump-抓包"><a href="#tcpdump-抓包" class="headerlink" title="tcpdump 抓包"></a>tcpdump 抓包</h1><p>首先将电脑上的 tcpdump 直接推送到手机上(前提是手机 root 过</p><pre><code class="language-yaml">adb push tcpdump /data/local/tmp/adb shellsuchmod +x /data/local/tmp/tcpdump</code></pre><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250420233424962.png"></p><p>这是我刷过 root 的手机，此时已经可以通过 adb 进行操作</p><p>然后查看抓流量的接口</p><pre><code class="language-yaml">ip link show</code></pre><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250420233425109.png"></p><p>在这里我使用的是 wlan0，所以使用如下命令去抓数据包</p><pre><code class="language-yaml">/data/local/tmp/tcpdump -i wlan0 -s 0 -w /sdcard/wifi_traffic.pcap</code></pre><p>在抓完后用 adb 抓到电脑用电脑打开.pcap 文件</p><pre><code class="language-yaml">adb pull /sdcard/app_traffic.pcap</code></pre><p>设置过滤器</p><pre><code class="language-yaml">ip.src == 192.168.80.2 &amp;&amp; ip.dst == 192.168.80.1 &amp;&amp; udp</code></pre><p>中间人攻击（需要外置网卡）</p><p> 欺骗无人机，使其将地面站的流量发送到你  </p><p><code>sudo arpspoof -i wlan3 -t 192.168.80.1 -r 192.168.80.2</code></p><p> 欺骗地面站，使其将无人机的流量发送到你  </p><p><code>sudo arpspoof -i wlan3 -t 192.168.80.2 -r 192.168.80.1</code></p>]]></content>
    
    
    <summary type="html">记录一下对手机app与无人机通信抓包的流程</summary>
    
    
    
    <category term="抓包" scheme="https://ch0en3.github.io/categories/%E6%8A%93%E5%8C%85/"/>
    
    
    <category term="抓包" scheme="https://ch0en3.github.io/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>无线电安全基础-从PDU开始理解通信协议是如何构成的(发送篇/未完)</title>
    <link href="https://ch0en3.github.io/2025/04/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E4%BB%8EPDU%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%9E%84%E6%88%90%E7%9A%84(%E5%8F%91%E9%80%81%E7%AF%87%EF%BC%89/"/>
    <id>https://ch0en3.github.io/2025/04/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80-%E4%BB%8EPDU%E5%BC%80%E5%A7%8B%E7%90%86%E8%A7%A3%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%9E%84%E6%88%90%E7%9A%84(%E5%8F%91%E9%80%81%E7%AF%87%EF%BC%89/</id>
    <published>2025-04-05T16:00:00.000Z</published>
    <updated>2025-05-14T17:26:32.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PDU-是什么？"><a href="#PDU-是什么？" class="headerlink" title="PDU 是什么？"></a>PDU 是什么？</h1><p>简单理解就是数据块。GNUradio 传统上是流式数据。比如麦克风录音或者天线接收 IQ 数据，这些都是不停的流。但是在现代通信协议当中比如说 WIFI、蓝牙它们都是一包一包数据的进行传输。比如 WIFI 一帧一帧的发。所以每一包数据要整体处理，要知道包头，时间戳，长度等信息</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="一、在-gnuradio-当中如何生成一个-PDU"><a href="#一、在-gnuradio-当中如何生成一个-PDU" class="headerlink" title="一、在 gnuradio 当中如何生成一个 PDU"></a>一、在 gnuradio 当中如何生成一个 PDU</h2><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012458576.png"></p><p>通过 RandomPDU Generator 生成 PDU</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012501294.png"></p><p>其四个参数分别影响：PDU 长度范围最少为 15，最大为 150 字节，mask 与 pdu 每一字节做 AND 操作，总长度必须是 <code>Length Modulo</code> 的倍数。  </p><h2 id="二、PDU-CRC32-校验"><a href="#二、PDU-CRC32-校验" class="headerlink" title="二、PDU +CRC32 校验"></a>二、PDU +CRC32 校验</h2><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012504672.png"></p><p>在上一个示例的基础上加了 CRC32 校验</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012506499.png"></p><p>先生成一个随机 pdu 包 然后在其尾部补充 4 个 CRC32 校验值</p><h2 id="三、一个数据帧的完整实现"><a href="#三、一个数据帧的完整实现" class="headerlink" title="三、一个数据帧的完整实现"></a>三、一个数据帧的完整实现</h2><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012551137.png"></p><p>在示例二的基础之上我们再加上了 protocol formatter。这个模块的作用是可以根据 Header Format Object 的内容将输入的 PDU 格式化后生成一个符合协议要求的 header 并且再和原先的 payload 组合成新的 PDU</p><p>再来看Header Format Object 的内容是如何定义的</p><table><thead><tr><th align="left">参数</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left"><strong>Access Code</strong></td><td align="left"><code>&#39;101010101111101010101&#39;</code></td></tr><tr><td align="left"><strong>Threshold</strong></td><td align="left"><code>3</code></td></tr><tr><td align="left"><strong>Payload Bits per Symbol</strong></td><td align="left"><code>1</code></td></tr></tbody></table><p>我们来分别解析这些参数的含义：</p><ol><li><strong>Access Code</strong> 是一个 “帧同步字”（syncword）。通常发射端会在每个数据包前加上这段固定的比特序列，用来帮助接收端<strong>找到包的起始位置</strong>。  </li><li><strong>Threshold</strong>：在检测 Access Code 时，允许最多3位bit错误（适应噪声）。</li><li><strong>Payload Bits per Symbol</strong>：1bit对应1个符号（典型的二进制系统，比如 BPSK调制）</li></ol><p>来说总结：**Header Format 定义了如何构造前导同步字、以及头部要携带的内容。 **</p><p>那么最终的数据包格式为</p><pre><code class="language-yaml">[Access Code] + [Header] + [Payload]</code></pre><p>但是 Access Code不是在PDU本体里，而是更像一个<strong>附加前缀</strong>。Access Code并不会直接出现在PDU里面，因为PDU属于逻辑层封装，Access Code是物理层同步信号。    </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012554288.png"></p><p>这个过程是这样的</p><pre><code class="language-yaml">[ Access Code ] + [ PDU（Header + Payload + CRC） ]    ↓进入物理层调制    ↓发送</code></pre><p>在这里出现的 PDU 只有Header + Payload + CRC 部分 不含Access Code </p><h2 id="四、合并输出"><a href="#四、合并输出" class="headerlink" title="四、合并输出"></a>四、合并输出</h2><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012558369.png"></p><p>在上面三个例子我们从 GNUradio 是如何输出 PDU 开始到生成一个完整的数据帧。那么现在我们来开始将其合并起来。可能初看这个流程图会觉得很复杂 但是其实它只是将我们前面所学的内容增加了流的输出部分。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012602444.png"></p><p>这里是我们示例三当中的内容，用于生成 PDU。然后分别输出 header 和 payload 到 PDU to Tagged Stream 块当中。该块顾名思义就是将 PDU 转成流</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012606273.png"></p><p>可以来看一下是如何转化为流的，首先会打包比特。将 8 比特输入的信息转化为 1 比特输出。紧接着进行一个 Map 运算。这个操作比较简单仅仅是将输入改为输出的值。其实就是数据类型的转化（ bit 0 -&gt; byte 0; bit 1 -&gt; byte 1 ）</p><p>然后就到了比较复杂的地方了 Chunks to Symbols 这个块会将我们传输的 byte 转化成对应的 symbol 以便后续传输</p><p><strong>那 symbol 是什么呢？ <strong>在数字通信中，“符号”是用来表示一个或多个比特的最小传输单位。它不再是简单的 0 或 1，而是一个具有特定数值的信号单元，通常是复数（在这个流程图中是实数，因为是 BPSK）。这些符号就是我们说的</strong>“星座图”</strong>。 </p><p>这又涉及到一个概念，<strong>什么是星座图？</strong></p><p>简单来说星座图就是一个字典，它的定义在 Constellation Object中<img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012609967.png"></p><p>可以来解析一下该星座图：</p><ul><li>ID 是星座图名称</li><li><strong>Constellation Type: Variable Constellation</strong>: 表示这是一个可变星座图对象。</li><li><strong>Symbol Map: digital.psk_2(1)</strong>: 这是关键。它不直接写出 <code>0, 1</code> 这个列表，而是调用了一个函数 <code>digital.psk_2(1)</code> 来生成符号映射表。 <ul><li><code>digital.psk_2</code> 在 GNU Radio 中特指 <strong>BPSK (Binary Phase Shift Keying)</strong> 调制。</li><li>参数 <code>(1)</code> 通常表示 <strong>每符号的比特数 (bits per symbol)</strong>。所以 <code>digital.psk_2(1)</code> 就是获取 <strong>1 比特&#x2F;符号 BPSK</strong> 的符号映射表。</li><li>对于 BPSK (1 bit&#x2F;symbol)，标准的符号映射表通常是：输入比特 0 对应第一个星座点，输入比特 1 对应第二个星座点。这个函数调用会生成这个 <code>[0, 1]</code> 的映射列表。</li></ul></li><li><strong>Constellation Points: digital.psk_2(0)</strong>: 同样，这里调用了函数 <code>digital.psk_2(0)</code> 来生成星座点的列表。 <ul><li>参数 <code>(0)</code> 通常表示获取这个调制方案的<strong>星座点本身</strong>。</li><li>对于标准的 BPSK，星座点是位于实数轴上的 <strong>-1 和 1</strong>。这个函数调用会生成这个 <code>[-1, 1]</code> 的星座点列表（这里的截图显示是 <code>[complex_vector]</code>，但对于 BPSK，虚部是 0，所以实际上是 <code>[-1+0j, 1+0j]</code>，也就是实数 -1 和 1）。</li></ul></li></ul><p>剩下的一些参数不影响我们的内容。简单来说 这个 <code>Constellation Object</code> 块的作用不仅仅是简单地存贮 <code>-1, 1</code> 和 <code>0, 1</code> 这两个列表，它通过调用 <code>digital.psk_2</code> 这个函数，明确地声明了它定义的是一个 <strong>BPSK (1比特&#x2F;符号) 调制方案的星座图</strong></p><p>回到我们的解析当中。那么Chunks to Symbols 具体是如何工作的呢？首先从星座图我们可以知道符号分别被定义为了-1，1. 其对应的比特内容为 0，1.这里可以理解为经过Chunks to Symbols 处理后：</p><ul><li>原始信息是 0 的时候，就用符号 -1</li><li>原始信息是 1 的时候，就用符号 1</li></ul><p>.<strong>这里是个符号上的对应关系.不是实际的数学意义上的值</strong>。这个过程其实就是 Chunks to Symbol 去星座图当中去查询对应的 Symbols，然后将输入的内容翻译成星座图当中对应的符号再输出。（实际上这是个数学的过程，但是在这里我们也没必要深入研究）</p><pre><code class="language-yaml">输入原始比特 (0 或 1)↓根据“星座图（Constellation Object 定义的规则）查找对应的“symbol”↓输出查找到的“symbol” (-1 或 1)</code></pre><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012614453.png">那么经过 Chunks to Symbol 处理后就输出到一个 Vitrual Sink 的块当中。这个块的作用是可以用来传输流。这里可以看到我们将处理好的 payload 流和 header 流混合再一起后进行输出。最后显示再外面时域和邻域图上</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012617954.png"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012621188.png"></p><p>这样我们完成了一个 PDU 从十六进制转换为比特的操作</p>]]></content>
    
    
    <summary type="html">从PDU开始理解通信协议是如何构成的(发送篇)</summary>
    
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    <category term="GNURADIO" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/GNURADIO/"/>
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    <category term="GNURADIO" scheme="https://ch0en3.github.io/tags/GNURADIO/"/>
    
  </entry>
  
  <entry>
    <title>无线电安全基础-GNURADIO流程图入门</title>
    <link href="https://ch0en3.github.io/2025/04/gnuradio%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%85%A5%E9%97%A8/"/>
    <id>https://ch0en3.github.io/2025/04/gnuradio%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%85%A5%E9%97%A8/</id>
    <published>2025-04-04T16:00:00.000Z</published>
    <updated>2025-05-14T17:29:19.583Z</updated>
    
    <content type="html"><![CDATA[<p> 回顾课堂学的信号系统，高频电子线路，数字信号处理，通信原理四大神书</p><h1 id="一-最基础的流程图"><a href="#一-最基础的流程图" class="headerlink" title="一.最基础的流程图"></a>一.最基础的流程图</h1><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012021777.png"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012021815.png"></p><p>信号与系统知识回顾</p><p>上面为时域图。时域的定义是描绘时间随信号如何变化</p><p>下面为频域图。频域用来描述信号包含哪些频率成分</p><p><strong>时域</strong>：信号<strong>随时间怎么变化</strong><br>（你看到的是波形——起伏、快慢、周期性）</p><p> <strong>频域</strong>：信号<strong>包含哪些频率成分、各有多强</strong><br>（你看到的是频谱——哪些频率占主导，谁强谁弱）</p><p>从时域到频域使用的是傅里叶变换</p><h1 id="二-比特的打包与解包"><a href="#二-比特的打包与解包" class="headerlink" title="二.比特的打包与解包"></a>二.比特的打包与解包</h1><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012018853.png"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012020258.png"></p><p>主要演示的是如何将原始字节比特打包成符号。</p><p>意义： 把一串比特打包成一个数值（可以是十进制，也可以转成十六进制字符）  </p><h1 id="三-基于层创建-block"><a href="#三-基于层创建-block" class="headerlink" title="三.基于层创建 block"></a>三.基于层创建 block</h1><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012025054.png"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012027693.png"></p><p>先设置一个流程图，接着点启动按钮旁边的按键保存<img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012909763.png"></p><p>这里可以看到保存好了<img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012032196.png"></p><h1 id="四、滤波器的实现"><a href="#四、滤波器的实现" class="headerlink" title="四、滤波器的实现"></a>四、滤波器的实现</h1><p>原理</p><p>低通滤波器：只允许低频信号通过 挡住高频信号</p><p>高通滤波器：只允许高频信号通过 挡住低频信号</p><p>带通滤波器：只允许某一段频率范围的信号通过，其它全过滤</p><p>带阻滤波器：不允许某一段频率范围的信号通过，其它全接收</p><p>滤波器对不同频率信号的响应情况可以通过通频带、阻频带、截止频率等参数来描述。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012034532.png"></p><h1 id="五、ZMQ-的使用"><a href="#五、ZMQ-的使用" class="headerlink" title="五、ZMQ 的使用"></a>五、ZMQ 的使用</h1><p>ZMQ 最主要的作用是可以将 GNU Radio 中的实时数据流通过 socket 引到外面的 python&#x2F;c 等大型应用程序中做数据分析、展示等。</p><p><a href="https://www.cnblogs.com/zjutlitao/p/17354483.html">https://www.cnblogs.com/zjutlitao/p/17354483.html</a></p><p>ZMQ 的几种应用场景</p><p>1.本机上两个不同的 gnuradio 文件之间相互通信。</p><p>以 AM 信号发送接收机为例</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012038492.png"></p><p>回顾一下上课知识<img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012042494.png"></p><p>AM 调频的核心思想：<img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012048535.png"></p><p>以下内容按顺序为从左到右</p><ol><li>首先使用 audio source 输出一个采样率为 48Khz 的模拟信号表示 m(t)</li><li>通过 repeat 将 48KHZ 的音频信号插值到 768Khz。插值后的信号依然是m(t)，只不过变成了 768 个样点</li><li>Multiply Const（乘以 1 ）实际可以用来控制音频幅度</li><li>Add Const + 1 .这是因为由 AM 公式可得如果 m(t) 有负数，就可能使调制深度超过 100%，造成“过调制”所以加 1 是为了把信号偏移到正区间，避免过调制</li><li>Signal source（载波）<img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012050933.png">频率和采样率与音频保持一致</li><li>Multiply（调制器） 这一步实现了真正的调幅<img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012053714.png"> 输出为 S(t)</li><li>结果输出到 ZMQ 和时域图</li></ol><p>（注意调制信号和载波都要设置为相同的值）</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012056147.png"></p><p>在前面我们已经演示如何发送端输出已调信号。现在在接收端要做的事情是解调将其还原为最初的 mt 信号</p><p>那么 AM 最经典的解调方式是包络解调</p><ol><li>首先 source 的信号就是发送机发送的 s(t)</li><li><code>Frequency Xlating FIR Filter</code>（频率平移 + 滤波 + 降采样）  中心设为 48Khz 再将频率搬移到基带 0hz 附近。使得目标信号在滤波器通带中心。接着使用低通滤波器只保留 [1 + m(t)] 的频带部分 。降采样（Decimation&#x3D;16）</li><li>AGC(自动增益控制)防止包络检测失真</li><li><code>Complex to Mag</code>包络检测提取调幅信号的包络部分（调制内容）  模块自动完成底层的计算工作</li><li>Band Pass Filter  低通滤波器过滤直流分量 1 只保留 m(t)部分</li><li><code>Multiply Const</code> 同上音量调整</li><li>结果输出为时域图</li></ol><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012058677.png"></p><p>2.不同电脑可以使用局域网进行传输</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012102687.png"></p><p>这里主要是由 REQ&#x2F;REP 的方式传递信息 原理如图所示</p><p>代码比较简单。先通过 ZMQ <code>REQ</code> socket 接收消息，再把消息转换为大写，再然后通过 ZMQ <code>REP</code> socket 发送回去消息。格式为 GNU Radio 的 <strong>PMT（Polymorphic Type）。但是这个过程是双向的请求响应，适用于客户端和服务器的应答</strong></p><pre><code class="language-yaml">#!/usr/bin/python3# -*- coding: utf-8 -*-# zmq_REQ_REP_server.py# This server program capitalizes received strings and returns them.# NOTES:#   1) To comply with the GNU Radio view, messages are received on the REQ socket and sent on the REP socket.#   2) The REQ and REP messages must be on separate port numbers.import pmtimport zmq_debug = 0          # set to zero to turn off diagnostics# create a REQ socket_PROTOCOL = &quot;tcp://&quot;_SERVER = &quot;127.0.0.1&quot;          # localhost_REQ_PORT = &quot;:50246&quot;_REQ_ADDR = _PROTOCOL + _SERVER + _REQ_PORTif (_debug):    print (&quot;&#39;zmq_REQ_REP_server&#39; version 20056.1 connecting to:&quot;, _REQ_ADDR)req_context = zmq.Context()if (_debug):    assert (req_context)req_sock = req_context.socket (zmq.REQ)if (_debug):    assert (req_sock)rc = req_sock.connect (_REQ_ADDR)if (_debug):    assert (rc == None)# create a REP socket_PROTOCOL = &quot;tcp://&quot;_SERVER = &quot;127.0.0.1&quot;          # localhost_REP_PORT = &quot;:50247&quot;_REP_ADDR = _PROTOCOL + _SERVER + _REP_PORTif (_debug):    print (&quot;&#39;zmq_REQ_REP_server&#39; version 20056.1 binding to:&quot;, _REP_ADDR)rep_context = zmq.Context()if (_debug):    assert (rep_context)rep_sock = rep_context.socket (zmq.REP)if (_debug):    assert (rep_sock)rc = rep_sock.bind (_REP_ADDR)if (_debug):    assert (rc == None)while True:    #  Wait for next request from client    data = req_sock.recv()    message = pmt.to_python(pmt.deserialize_str(data))    print(&quot;Received request: %s&quot; % message)    output = message.upper()    #  Send reply back to client    rep_sock.send (pmt.serialize_str(pmt.to_pmt(output)))</code></pre><p>再来看一段基于 PUSH_PULL 的消息传输脚本。使用 ZMQ <code>PULL</code> socket 接收 PMT 消息（从客户端或 GNU Radio）。将消息转换为大写（字符串处理）再通过 ZMQ <code>PUSH</code> socket 发送回去（可以广播给多个客户端。这构建的是一个 <strong>消息处理节点</strong>，支持多个接收者（fan-out）。</p><pre><code class="language-yaml">#!/usr/bin/python3# -*- coding: utf-8 -*-# zmq_PUSH_PULL_server.pyimport sysimport pmtimport zmq_debug = 0          # set to zero to turn off diagnostics# create a PUSH socket_PROTOCOL = &quot;tcp://&quot;_SERVER = &quot;127.0.0.1&quot;          # localhost_PUSH_PORT = &quot;:50252&quot;_PUSH_ADDR = _PROTOCOL + _SERVER + _PUSH_PORTif (_debug):    print (&quot;&#39;zmq_PUSH_PULL_server&#39; version 20068.1 binding to:&quot;, _PUSH_ADDR)push_context = zmq.Context()if (_debug):    assert (push_context)push_sock = push_context.socket (zmq.PUSH)if (_debug):    assert (push_sock)rc = push_sock.bind (_PUSH_ADDR)if (_debug):    assert (rc == None)# create a PULL socket_PROTOCOL = &quot;tcp://&quot;_SERVER = &quot;127.0.0.1&quot;          # localhost_PULL_PORT = &quot;:50251&quot;_PULL_ADDR = _PROTOCOL + _SERVER + _PULL_PORTif (_debug):    print (&quot;&#39;zmq_PUSH_PULL_server&#39; connecting to:&quot;, _PULL_ADDR)pull_context = zmq.Context()if (_debug):    assert (pull_context)pull_sock = pull_context.socket (zmq.PULL)if (_debug):    assert (pull_sock)rc = pull_sock.connect (_PULL_ADDR)if (_debug):    assert (rc == None)while True:    #  Wait for next request from client    data = pull_sock.recv()    message = pmt.to_python(pmt.deserialize_str(data))    # print(&quot;Received request: %s&quot; % message)    output = message.upper()    # capitalize message    #  Send reply back to client    push_sock.send (pmt.serialize_str(pmt.to_pmt(output)))</code></pre><p><strong>如何将 GNURADIO 的数据进行导出做信号处理</strong></p><p>该流程图 其中 signal source 即是我们所收集到的信号。这个流程图可以使得信号通过 TCP 的方式在局域网传输</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012110098.png"></p><p>以下是接收脚本的例程，以方便做进一步的数据分析</p><pre><code class="language-yaml">#!/usr/bin/python3# -*- coding: utf-8 -*-# zmq_SUB_proc.py# Author: Marc Lichtmanimport zmqimport numpy as npimport timeimport matplotlib.pyplot as pltcontext = zmq.Context()socket = context.socket(zmq.SUB)socket.connect(&quot;tcp://127.0.0.1:55555&quot;) # connect, not bind, the PUB will bind, only 1 can bindsocket.setsockopt(zmq.SUBSCRIBE, b&#39;&#39;) # subscribe to topic of all (needed or else it won&#39;t work)while True:    if socket.poll(10) != 0: # check if there is a message on the socket        msg = socket.recv() # grab the message        print(len(msg)) # size of msg        data = np.frombuffer(msg, dtype=np.complex64, count=-1) # make sure to use correct data type (complex64 or float32); &#39;-1&#39; means read all data in the buffer        print(data[0:10])        # plt.plot(np.real(data))        # plt.plot(np.imag(data))        # plt.show()    else:        time.sleep(0.1) # wait 100ms and try again</code></pre><h1 id="六、Message-strobe-的使用"><a href="#六、Message-strobe-的使用" class="headerlink" title="六、Message strobe 的使用"></a>六、Message strobe 的使用</h1><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012113708.png"></p><p>流程图如上 主要修改 PMT 部分</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250515012119190.png"></p><p>关于 PMT 如何构造可以看文档</p><p><a href="https://wiki.gnuradio.org/index.php/Polymorphic_Types_(PMTs)">https://wiki.gnuradio.org/index.php/Polymorphic_Types_(PMTs)</a></p><p>GNURADIO 本来是处理连续的数据流（IQ流、音频流），但有时候需要传递非流式的信息（比如控制命令、标签、事件），那么久需要使用 PMT。PMT 简单介绍就是 GNURADIO 自身的一套数据类型用于传输和转换信息</p><p>那么可以可以使用 Message Storbe 向其它模块发送 PMT 消息从而达到调试的目的，还可以用 Message Debug 块来调试信息流</p>]]></content>
    
    
    <summary type="html">GNURADIO流程图入门</summary>
    
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    <category term="GNURADIO" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/GNURADIO/"/>
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    <category term="GNURADIO" scheme="https://ch0en3.github.io/tags/GNURADIO/"/>
    
  </entry>
  
  <entry>
    <title>硬件黑客-Pwnagotchi</title>
    <link href="https://ch0en3.github.io/2025/03/%E7%A1%AC%E4%BB%B6%E9%BB%91%E5%AE%A2-Pwnagotchi/"/>
    <id>https://ch0en3.github.io/2025/03/%E7%A1%AC%E4%BB%B6%E9%BB%91%E5%AE%A2-Pwnagotchi/</id>
    <published>2025-03-16T04:49:07.784Z</published>
    <updated>2025-03-16T11:49:09.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="beN5t">介绍</h1><p>Pwnagotchi是一个基于a2c的“ai”，由bettercap提供支持，它从周围的WiFi环境中学习，以最大限度地获取可破解的WPA密钥材料(通过被动嗅测或执行去认证和关联攻击)。这些资料以PCAP文件的形式收集在磁盘上，包含hashcat支持的任何形式的可破解握手，包括完整的和一半的WPA握手以及PMKIDs。</p><p>简单点说的话它就是一个可以帮助你捕获破解wifi所需要握手包的工具（其实重点在它像个电子宠物一样</p><h2 id="dGmid">工作原理</h2>只需要知道它可以进行深度学习就行，但是有一点不一样的地方是。它与通常的强化学习模拟不同，Pwnagotchi实际上是在人类的时间尺度上学习的，因为它是与现实世界的环境互动，而不是一个定义良好的虚拟环境(比如玩超级马里奥)。一幅画的时间是用年代来衡量的;一个epoch可以持续几秒到几分钟，这取决于有多少接入点和客户端站可见。<p>不要期望你的Pwnagotchi在一开始就表现得非常好，因为它将探索几个关键参数的组合，以确定在开始阶段对特定环境的理想调整。但当你的Pwnagotchi告诉你它很无聊的时候，一定要听!把它带到新的WiFi环境中，让它观察新的网络，捕捉新的握手——你会看到的。：）</p><p>随着时间的推移，两个或更多的Pwnagotchi单位一起训练，将学会合作，通过分配可用的频道来探测彼此的存在。（有点类似于边缘计算</p><h2 id="YKAWo">攻击原理</h2>在连接到无线接入点的客户端设备(例如，连接到家庭WiFi网络的手机)能够安全地传输和接收来自该接入点的数据之前，需要进行一个称为4次握手的过程，以便生成WPA加密密钥。这个过程包括在客户端设备和AP之间交换四个数据包;它们用于从接入点的WiFi密码中获得会话密钥。一旦成功交换了数据包并生成了密钥，客户端设备就可以通过身份验证，并开始向无线AP发送和接收数据包(现在通过加密保护)。<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125053971.png"></p><p>问题出在四次握手的过程中，这四个握手包很容易被嗅探。一旦记录下来就可以使用字典或者暴力破解握手包并恢复原始wifi密钥。而在实战中我们甚至不需要全部4个握手包，只有一半即两个也可以以破解。在大多数情况下即使没有连接一个握手包就足够了。</p><h1 id="BdRNZ">硬件要求</h1>1. 一个树莓派zero w2. 至少8gb以上的内存的SD卡3. 移动电源供电（可以用充电宝也可以买专门为树莓派zero设计的ups-lite4. 一块水墨屏 waveshare 2.135. 一条结实可靠的micro usb数据线<p>均可以在淘宝上购买</p><h3 id="nQLy9">如何安装</h3>[https://pwnagotchi.ai/installation/#flashing-an-image](https://pwnagotchi.ai/installation/#flashing-an-image)<p>最方便的方式就是使用官方提供的镜像，使用<a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a>进行写入</p><p>安装步骤如下</p><ol><li>下载镜像文件</li><li>下载 balenaetcher并且安装</li><li>连接好读卡器</li><li>打开balenaetcher选择树莓派镜像</li><li>写入卡中</li></ol><details class="lake-collapse"><summary id="uf207c31d"><span class="ne-text">这里记录一下踩坑的一些点</span></summary><p id="udc0ca7be" class="ne-p"><span class="ne-text">在淘宝上买屏幕我们买的是v3版本的，在官方镜像中不兼容。所以建议下载1.56 beta版本的镜像</span></p><p id="ua0de47c1" class="ne-p"><a href="https://github.com/DrSchottky/pwnagotchi/releases" data-href="https://github.com/DrSchottky/pwnagotchi/releases" target="_blank" class="ne-link"><span class="ne-text">https://github.com/DrSchottky/pwnagotchi/releases</span></a></p><p id="u95221cc7" class="ne-p"><span class="ne-text"></span></p><p id="u5eba149c" class="ne-p"><span class="ne-text">关于如何安装带有v3屏幕的pwnagochi这里是教程</span></p><p id="u879b6f08" class="ne-p"><a href="https://pwnsec.io/how-to-make-a-pwnagotchi-in-2022-with-a-waveshare-v3-screen/" data-href="https://pwnsec.io/how-to-make-a-pwnagotchi-in-2022-with-a-waveshare-v3-screen/" target="_blank" class="ne-link"><span class="ne-text">https://pwnsec.io/how-to-make-a-pwnagotchi-in-2022-with-a-waveshare-v3-screen/</span></a></p><p id="u09082f7f" class="ne-p"><br></p><p id="u5f59b89a" class="ne-p"><span class="ne-text">省流版本的话就是在安装1.56版本的镜像后把config.toml的内容更改为</span></p><p id="ud17ff7bc" class="ne-p"><span class="ne-text">main.name = “NameOfYourPwnagotchi”<br /></span><span class="ne-text">main.lang = “en”<br /></span><span class="ne-text">main.whitelist = [<br /></span><span class="ne-text">“YourWifiYouDontWantToSniff”<br /></span><span class="ne-text">]</span></p><p id="uebcbe049" class="ne-p"><span class="ne-text">main.plugins.grid.enabled = false<br /></span><span class="ne-text">main.plugins.grid.report = false<br /></span><span class="ne-text">main.plugins.grid.exclude = [<br /></span><span class="ne-text">“YourHomeNetworkHere”<br /></span><span class="ne-text">]</span></p><p id="ud23ee860" class="ne-p"><span class="ne-text">ui.display.enabled = true<br /></span><span class="ne-text">ui.display.type = “waveshare_3”<br /></span><span class="ne-text">ui.display.color = “black”</span></p><p id="u86745c63" class="ne-p"><span class="ne-text">personality.advertise = false<br /></span><span class="ne-text">personality.deauth = false</span></p></details><p>以上是装在树莓派zero w中的。这是linux版本教程</p><p><a href="https://pwnagotchi.ai/installation/#installing-on-any-gnu-linux">https://pwnagotchi.ai/installation/#installing-on-any-gnu-linux</a></p><h3 id="H6kAV">安装完后的配置</h3>在安装好镜像后需要做的第一件事情是进行配置。通过读卡器在SD卡boot目录下面新建一个config.toml文件。然后输入以下内容<pre><code class="language-python">main.name = &quot;pwnagotchi&quot;main.lang = &quot;en&quot;main.whitelist = [  &quot;EXAMPLE_NETWORK&quot;,  &quot;ANOTHER_EXAMPLE_NETWORK&quot;,  &quot;fo:od:ba:be:fo:od&quot;,  &quot;fo:od:ba&quot;]main.plugins.grid.enabled = truemain.plugins.grid.report = truemain.plugins.grid.exclude = [  &quot;YourHomeNetworkHere&quot;]ui.display.enabled = trueui.display.type = &quot;waveshare213d&quot;ui.display.color = &quot;black&quot;</code></pre><p>接着把micro usb线连接上电脑</p><p>注意！这里很有可能出现连接电脑后识别不出的情况，这是因为在正常情况下windows系统会把rndis识别成串口，我们需要做的是打上驱动</p><p><a href="https://blog.csdn.net/baidu_32237719/article/details/78189144">https://blog.csdn.net/baidu_32237719&#x2F;article&#x2F;details&#x2F;78189144</a></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125103412.png"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125101186.png"></p><p>安装成功</p><h1 id="kSWXR">如何使用</h1><h2 id="FGFtx">模式介绍</h2>**MANU模式**<p>在连接到设备usb数据接口的情况下它将以手动模式启动，它能够读取一些日志文件并在屏幕上统计数据。这是当想要从单位传输数据时候应该使用的模式</p><p><strong>AUTO模式</strong></p><p>如果在只连接usb电源端口的情况下这是设备默认启动的模式。例如只有连接段源码却没有连接到电脑数据端口上时。自动模式下单位将自动开始操作执行攻击</p><p><strong>AI模式</strong></p><p>如果你在默认配置中启动了ai模式，auto模式将在几分钟后转换为ai（它的转换时间取决于sd卡的读取速度）。这段时间被用于加载ai模块所使用的所有依赖并且初始化神经网络。一旦依赖被加载，即&#x2F;root&#x2F;brain.nn文件会被唤醒，ai模式将自动选择最佳的参数集。这取决于它训练了多长时间</p><h2 id="pwHAj">ui</h2>如果通过usb0连接到设备并在网络接口上设置了静态地址。在默认情况下它的地址是[http://pwnagotchi.local:8080/](http://pwnagotchi.local:8080/)<p>它的默认用户名和密码都是changeme，如果你想要把它更改为自己的名字可以在config.toml中更改</p><h3 id="WZDpd">墨水屏配置和详细解读</h3>![](https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125110613.png)<ul><li><strong>CH</strong>:这显示的是当前运行的channel，当在所有通道上执行嗅探和跳频时候它将显示*而不是一个具体的数字。它在嗅探的时候会收集每个频道上的ap数量。</li><li><strong>AP</strong>:显示的是当前信道上的接入点数量，括号中显示了所有通道的可见访问点总数（根据最后一次嗅探的信道</li><li><strong>UP</strong>:设备的正常运行时间，自上次重新启动以来。格式为hh:mm:ss。</li><li><strong>PWND</strong>:在当前会话中捕获的握手次数。括号中显示的是pwnagochi从安装开始至少握手过唯一ssid的数量，花括号中显示的是pwnagochi最近一次进行握手的ssid</li><li><strong>MODE</strong>:表示pwnagochi当前以什么模式进行运行<ul><li><strong>MANU</strong></li><li>这种模式适合更新和备份你的单位和使用bettercap的web UI。</li><li>Pwnagotchi在手动模式下不会嗅或捕捉握手。</li><li>陷入手动模式?打开未连接USB网线的设备。</li><li><strong>AUTO</strong></li><li>在这种模式下Pwnagotchi仍然会嗅探并捕获握手;它主要是功能性的——自动模式和人工智能模式之间的主要区别是，它的行动是由静态算法决定的，而不是由人工智能决定Pwnagotchi应该做什么来获得最佳pwnage。</li><li>一旦AI依赖项被引导并且神经网络完成加载，这就消失了。(按RPi0W计算，这个过程大约需要20-30分钟。)</li><li>如果你在没有启用AI的情况下运行Pwnagotchi，这是你将保持的模式。</li><li><strong>AI</strong></li><li>一旦出现了这样标识就表明pizerow准备好开始训练了</li></ul></li></ul><p>成品展示</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316191036396.jpg" alt="Image_7140246746598"></p>]]></content>
    
    
    <summary type="html">这是一篇关于Pwnagotchi简要介绍。
</summary>
    
    
    
    <category term="wifi" scheme="https://ch0en3.github.io/categories/wifi/"/>
    
    
    <category term="hardware" scheme="https://ch0en3.github.io/tags/hardware/"/>
    
    <category term="wifi" scheme="https://ch0en3.github.io/tags/wifi/"/>
    
  </entry>
  
  <entry>
    <title>门禁控制系统(PACS)与OSDP攻击研究</title>
    <link href="https://ch0en3.github.io/2025/03/%E9%97%A8%E7%A6%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EOSDP%E6%94%BB%E5%87%BB%E7%A0%94%E7%A9%B6/"/>
    <id>https://ch0en3.github.io/2025/03/%E9%97%A8%E7%A6%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EOSDP%E6%94%BB%E5%87%BB%E7%A0%94%E7%A9%B6/</id>
    <published>2025-03-16T04:32:22.517Z</published>
    <updated>2025-03-16T04:58:33.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uMEsn">门禁控制系统原理</h1>一个标准的门禁控制系统由几部分组成。门，锁，rfid 读卡器。<p>一个正常的流程如图所示</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125708385.png"></p><p>一个带有门禁卡权限的人把门禁卡放在读卡器上，读卡器就会正确的读卡并开门。但是这个过程中要注意的是，读卡器并不会对你的卡进行鉴权，它只能够读取卡片并且将卡片的内容发送到位于后端的控制器并由控制器进行判断。如果控制器接收到的信息是正确的，控制器再发送开门的命令给锁并且发送一个信号给读卡器使得读卡器亮正确的灯</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125712042.png"></p><p>然而在读卡器传输信息到控制器这个过程当中是完全没有加密的。这是因为一种名为韦根（wiegand）协议。因此我们很容易就能够实现中间人攻击去获取正确的权限。有一个名为 espkey(<a href="https://github.com/octosavvi/ESPKey">https://github.com/octosavvi/ESPKey</a>) 的设备可以很轻松的完成这一点</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125715174.png"></p><h1 id="LP8KS">OSDP 背景介绍</h1>因此在以上的基础之上，OSDP 被提出用于替代韦根协议。OSDP 对读卡器到控制器这一过程进行了加密并且采用了强加密算法。保证传输过程无法被解密![](https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125718325.png)<p>在 OSDP 中为了防止简单的重放攻击，它对协议包的加密是这样的：在正确的数据后面会加上一个序列号以确保每一条信息都一致。接着他们被打包为 hmac</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125720984.png"></p><p>因此直接破解加密信息是完全不现实的。</p><p>在此基础之上 OSDP 还使用了 AES-CBC 模式来加密通信数据 </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125723451.png"></p><p>在上述 OSDP 的背景之下.HMAC 有一个非常不好的一点就是它实际上只有前 32 个字节是被维护的，后面 96 个字节实际上是可被丢弃的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125725863.png"></p><p>这一功能在规范当中是被这么描述的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125727984.png"></p><p>甚至为了减少传输时间，只发送 4 个字节。</p><p>这就意味着，我们可以使用生日攻击去破解这 32 位字节</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125730507.png"></p><p>这个过程中不涉及到任何新的数据，我们只是在一遍又一遍的重复播放上述收集到的信息.</p><p>容易出现漏洞的地方</p><p>协议，库，配置</p><h1 id="KzWPx">针对 OSDP 的攻击方式</h1>针对 OSDP 有一个名为 mellon 的工具[https://github.com/BishopFox/mellon](https://github.com/BishopFox/mellon)<h2 id="sc8bS">攻击方式 一 加密不强制</h2>osdp 支持加密并不强制性要求加密。osdp 支持一个安全通道但是这个并不是强制性要求的而是一个可选项![](https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125733475.png)<p>此外由于 OSDP 基于 RS485 协议运行，这是一个串行协议。因此如果有多个控制器，他们在系统当中应该是这样的。不同的阅读器同时存在同一根总线上与控制器相连接，所有的信息都通过总线传播</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125736754.png"></p><p>因此这就意味着，假设我想要打开的目标门禁为 A。我只需要把一个监听设备放在其它的读卡器位置就能收到门禁 A 的信息。</p><p>在 OSDP 系统当中，所有的读卡器都是客户端，只有控制器是服务端。所有的信息都是由控制器发送，而读卡器只能够回复</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125739013.png"></p><h2 id="p6l1r">攻击方式 2 降级攻击</h2>当读卡器启动的时候，控制器和读卡器之间会有一个握手，控制器会像读卡器发出一个质询去询问读卡器的能力<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125741122.png"></p><p>接着读卡器就会返回一些基础信息给控制器。例如是否有生物指纹信息，有键盘数据等等..在这堆数据里面有一个很有趣的东西叫做通信安全位。所以我们可以在这中间加入 mellon。当读卡器启动的时候，它向控制器返回一些信息, 将这个通信安全位从 1 被篡改为 0 了。控制器就会自然而然的认为读卡器不支持加密，这样 降级攻击就完成了<img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125743387.png"></p><h2 id="hD3pZ">攻击方式 3 安装模式  </h2><font style="color:rgb(55, 65, 81);">OSDP 有一个准官方的 “安装模式”，适用于读卡器和控制器。顾名思义，它应该在首次设置读取器时使用。它的作用本质上是允许读者向控制器询问基本加密密钥 （SCBK） 是什么。</font><p><font style="color:rgb(55, 65, 81);">这本身并不是一个疯狂的想法。它基于 SSH：第一次的配置是不安全的，在配置完成后就会安全   。问题是，许多控制器被配置为永久保持 “安装模式” ，也许是永远保持 “安装模式”。一些控制器在完成后会让管理员手动单击退出 “install mode”。</font></p><p><font style="color:rgb(55, 65, 81);">当读卡器和控制器都处于安装模式，就像 SSH 的配对模式一样。读卡器会像控制器发出质询获取密钥</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125745765.png"></p><p>接着控制器会把加密的密钥返回给读卡器。问题是，如果安装模式没有退出的话。攻击者便可以重复这个流程，获取到 ssh 密钥</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125747680.png"></p><h2 id="zqP3I">攻击方式 4 弱键</h2>在数据包加密当中我们希望看到的数据结构应该是这样的<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125749854.png"></p><p>由头 明文 和数据构成。但这是被加密后的结果，而不是一截命令  </p><p>但这是实际上我们看到的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125751987.png"></p><p>实际上 command byte 会告诉我们信息是如何传输的。</p><p>例如 OSDP_RAW，OSDP_fmt,OSDP keyset 的信息</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125755994.png"></p><p>基本上，消息的密钥包含正在被传递的加密密钥。</p><p>为什么这会是一个安全问题？ 实际上这个问题与 OSDP 协议本身无关</p><p>在实现一个通信协议的时候它们实际会引用到很多很多的库。</p><p>这是加密密钥的层次结构。控制器中存储有一个或曾经有一个主密钥。会话密钥由该主密钥派生，然后进行实际加密.osdp的新标准摆脱了主密钥，因此只有会话基础密钥和加密密钥。</p><p> <img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125758299.png">     协议设置了这些但是实际上并没有说明我们应该如何导出会话基本密钥。我们可以在网络上找到很多 osdp 引用库的硬编码密钥。这些库正在使用这些密钥来进行基础的加密</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125800310.png"></p><p>假设我们通过设备从总线上获取了一些加密的密钥</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125802350.png"></p><p>现在我们可以尝试使用了一大堆无意义的升序数字或者降序数字，总共 1 千个密钥。如果真的猜出一个 那么这时候我们就可以解密了。</p><h2 id="imwXc">攻击方式 5 密钥集捕获</h2>这个过程只使用了 AES，问题是如果只使用对称加密而在这个过程中没有非对称算法对密钥加密该如何进行密钥交换？  <p>在这里使用的是一个名为 SCBK-D 的东西。</p><p>:::info<br><strong>SCBK-D</strong> 是 OSDP（Open Supervised Device Protocol）中的<strong>默认安全会话密钥（Secure Channel Base Key - Default）</strong>。在OSDP协议中，安全通信是通过一个安全通道来实现的，而这个通道的密钥就是<strong>SCBK</strong>（Secure Channel Base Key）。</p><h3 id="wQKpn">SCBK-D 的具体作用</h3>1. **安全通道**：在OSDP协议中，为了保护敏感数据（如认证信息或命令），设备之间可以建立一个加密的安全通道。这个通道依赖于一个基础密钥，称为SCBK。2. **SCBK-D 是默认密钥**：    - **SCBK-D（Secure Channel Base Key - Default）** 是在设备没有被安全配置的情况下使用的默认密钥。    - 当使用默认密钥时，设备之间的通信并没有得到良好的保护，因为SCBK-D是一个标准的、已知的密钥，任何人都可以在公开文档中找到它。因此，设备默认的安全性较低，容易受到中间人攻击或其他形式的攻击。3. **安全建议**：出于安全考虑，生产环境中应避免使用SCBK-D。在部署系统时，应该使用特定的、安全配置的SCBK（非默认），通过配对双方的密钥来确保通信的机密性和完整性。<h3 id="J0COq">SCBK vs SCBK-D 的区别</h3>+ **SCBK（自定义密钥）**：    - SCBK是为每个设备自定义的密钥，用来建立安全通道，通常在设备初始化时进行配置。它提供了高等级的安全性。    - 这些自定义密钥可以通过安全方式配置，确保只有合法的控制面板和外围设备之间能够通信。+ **SCBK-D（默认密钥）**：    - SCBK-D是标准化的密钥，适用于设备出厂时的初始配置，用于测试或调试。使用默认密钥时，通信并不安全，容易被攻击。<p>:::</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125806046.png"></p><p>那么这里的 SCBK-D 其实就是我们上面提到的硬编码</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125808074.png"></p><p>那么作为一个攻击者如何才能够获取这个基本密钥？遗憾的是由于 OSDP 没有外带机制，因此我们如果想要获取这个基本密钥只能够是让控制器发送这个密钥才能获取它。</p><p>所以在实际的物理红队攻击当中我们可以设想这样的攻击场景</p><ol><li>损坏 RFID 读卡器。这有很多种办法，例如我们可以使用某些 NFC 工具使得 RFID 读卡器收到损害无法正常工作，或者直接暴力拆开。总之这一目的是使得读卡器无法正常工作</li><li>在 RS485 总线上放一个监听设备</li><li>等待读卡器被更换</li><li>通过网络获取 keyset 信息</li></ol>]]></content>
    
    
    <summary type="html">门禁控制系统(PACS)与OSDP攻击研究
</summary>
    
    
    
    <category term="rfid" scheme="https://ch0en3.github.io/categories/rfid/"/>
    
    
    <category term="rfid" scheme="https://ch0en3.github.io/tags/rfid/"/>
    
  </entry>
  
  <entry>
    <title>硬件黑客-Nrfbox</title>
    <link href="https://ch0en3.github.io/2025/03/%E7%A1%AC%E4%BB%B6%E9%BB%91%E5%AE%A2-nrfbox/"/>
    <id>https://ch0en3.github.io/2025/03/%E7%A1%AC%E4%BB%B6%E9%BB%91%E5%AE%A2-nrfbox/</id>
    <published>2025-03-15T18:27:00.000Z</published>
    <updated>2025-03-16T04:50:00.668Z</updated>
    
    <content type="html"><![CDATA[<p>该工具出自<a href="https://cifertech.net/nrfbox-your-all-in-one-gadget-for-ble-and-2-4ghz-networks/">https://cifertech.net/nrfbox-your-all-in-one-gadget-for-ble-and-2-4ghz-networks/</a></p><p>个人对这款工具做了一些小小的改进，增加了中继部分的功能。代码就不放了如果有感兴趣的师傅想要复现的可以私下交流</p><p>制作难度应该主要出现在硬件制作层面，这边分享一下我买的器件表。他提供的 bom 表在嘉立创很难找到合适的 需要自己去配</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110707854.jpeg"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110723825.jpeg" alt="1729504368429-c2f6e72c-c27b-457b-a3d0-4c6ea69c7adb"><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110834237.jpeg" alt="1729504369895-88554f1e-663d-4077-aaf3-8c7dbf8a4db3"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110844708.jpeg" alt="1729504371237-1be0c917-3731-4a34-b2d0-39b72e16c18e"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316111207852.jpeg"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316111212249.jpeg"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316111216233.jpeg"></p><p> <img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110907069.jpeg"></p><p>然后就是焊接的问题</p><p>主要多注意芯片和显示屏的引脚，因为引脚比较密所以很容易短路</p><p>一些成品照片</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316014221734.jpg" alt="36516482af4a94d6535d46997aafd19"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316014227301.jpg" alt="0af1b8325780dcbfeb562ed4f2c62ae"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316014230952.jpg" alt="f2f6989be1e77e4ef384f664891fbce"></p>]]></content>
    
    
    <summary type="html">这是一篇关于nrfbox简要介绍。
</summary>
    
    
    
    <category term="bluetooth" scheme="https://ch0en3.github.io/categories/bluetooth/"/>
    
    <category term="hardware" scheme="https://ch0en3.github.io/categories/bluetooth/hardware/"/>
    
    
    <category term="bluetooth" scheme="https://ch0en3.github.io/tags/bluetooth/"/>
    
    <category term="hardware" scheme="https://ch0en3.github.io/tags/hardware/"/>
    
  </entry>
  
  <entry>
    <title>车联网安全之PKES到PEPS中继攻击方案实现研究</title>
    <link href="https://ch0en3.github.io/2025/03/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E4%B9%8BPKES%E5%88%B0PEPS%E4%B8%AD%E7%BB%A7%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E7%A0%94%E7%A9%B6/"/>
    <id>https://ch0en3.github.io/2025/03/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E4%B9%8BPKES%E5%88%B0PEPS%E4%B8%AD%E7%BB%A7%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0%E7%A0%94%E7%A9%B6/</id>
    <published>2025-03-15T18:27:00.000Z</published>
    <updated>2025-03-18T09:34:01.347Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发自先知社区:<a href="https://xz.aliyun.com/news/17236">https://xz.aliyun.com/news/17236</a></p><h1 id="y9f07"><font style="color:#000000;">一、 PKES 系统 （Passive Keyless Entry and Start) 简介</font></h1><p><font style="color:#000000;">PKES 是质询优先系统。什么意思呢？即汽车会主动发出质询，并寻找钥匙答复的这么一种解决方案。如果钥匙在汽车发出的信号覆盖范围内，并且收到信息当中的特定模式，它就会回复汽车的消息。汽车通过 LF（125HZ）发送质询，因此汽车可以接收到的距离只有几英尺</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162559630.png"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162603461.png"></p><p><font style="color:#000000;">如图所示，这个过程可能会有两种配置方案</font></p><p><font style="color:#000000;">a)在一个典型的实现中，汽车周期性地用短信标探测通道是否存在钥匙。如果钥匙在范围内，汽车和钥匙之间的质询响应协议遵循授予或拒绝访问。鉴于密钥检测依赖于非常短的信标，这是低功耗的</font></p><p><font style="color:#000000;">b)在第二种实现中，汽车定期使用包含汽车标识符的较大质询信标直接探测通道。如果密钥在范围内，则直接响应质询。</font></p><h1 id="xOSjs"><font style="color:#000000;">二、中继攻击原理</font></h1><font style="color:#000000;">中继攻击的目标是即使钥匙卡不在低频信号的覆盖范围内，也能操纵汽车。我们通过在汽车和钥匙链之间设置一个继电器来实现这个目标。攻击的总体概述可能看起来像这样:</font><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162556607.png"></p><p><font style="color:#000000;">在这段描述当中，中继器由2个黑客与他们的能够接收和传输低频和高频信号射频设备组成。黑客 1收到汽车的质询，并将其转发给黑客 2。黑客 2向钥匙链发出信号。钥匙检查模式并回答问题的解决方案。黑客2捕获这个解决方案并将其传递给黑客1。然后黑客1对汽车播放信号。中继成功</font></p><p>:::info<br><font style="color:#000000;">中继攻击很难检测和阻止，因为它们破坏了协议中可能采用的所有传统加密机制:C只转发消息，而不需要破坏所使用的加密。这在非接触式应用程序的情况下更为严重:用户A只需将令牌(例如卡片或电话)带到读取器B的范围内，协议就会自动启动，无需获得特权的人的同意或输入。因此，可以不受阻碍地进行中继攻击。</font><font style="color:#000000;"></font></p><p>:::</p><p><font style="color:#000000;"></font></p><h1 id="RiQ5p"><font style="color:#000000;">三、深入研究 PKES 系统原理</font></h1><font style="color:#000000;">这里对 PKES 系统更进一步的进行研究。PKES 系统的作用是当携带钥匙的用户接近车辆时候自动解锁车辆。当用户远离车辆时，汽车自动锁定。这也是这一系统被称为 Passive 的原因，因为它不需要用户进行任何操作。钥匙与汽车之间的通信以磁耦合射频信号为特征。</font>**<font style="color:#000000;">在这个系统中，当钥匙“在汽车的通信范围内”时，汽车就会得出结论，认为钥匙离汽车很近。</font>**<p><font style="color:#000000;">PKES车钥匙使用LF RFID标签，提供短距离通信(主动在1-2米内，被动模式在几厘米内)，并使用成熟的UHF收发器进行远距离通信(在10到10米内)</font><font style="color:#000000;">LF通道用于检测钥匙扣是否在车内和车外区域内。图2(b)显示了为了安全方便地使用PKES系统，必须检测汽车附近的区域。区域如下:</font></p><ul><li><font style="color:#000000;">与汽车的远程距离(通常可达100米)。只有通过按钥匙链上的按钮才能打开&#x2F;关闭汽车。</font></li><li><font style="color:#000000;">在车外，但与门把手保持大约1 - 2米的距离。可以用门把手开&#x2F;关汽车。</font></li><li><font style="color:#000000;">车内。允许启动发动机。</font></li></ul><p><font style="color:#000000;">PKES协议因制造商而异。通常支持两种操作模式，即正常模式和备份模式。正常模式依赖于充电和工作的电池，而备用模式不需要电池(例如，当电池耗尽时)。表2总结了两种模式的位置和授权。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162609637.png"></p><p><font style="color:#000000;">图1显示了在正常模式下打开汽车的两个示例实现。汽车定期或当门把手被操作时在LF频道发送信标。这些信标可以是短的唤醒消息，也可以是包含汽车标识符的较大的质询消息。当密钥检测到LF通道上的信号时，它唤醒微控制器，解调信号并解释它。在计算对挑战的响应后，密钥在UHF信道上进行应答。当密钥检测到LF通道上的信号时，它唤醒微控制器，解调信号并解释它。在计算对</font><font style="color:#000000;">质询</font><font style="color:#000000;">的响应后，密钥在UHF信道上进行应答。当密钥检测到LF通道上的信号时，它唤醒微控制器，解调信号并解释它。在计算对</font><font style="color:#000000;">质询</font><font style="color:#000000;">的响应后，密钥在UHF信道上进行应答。汽车已收到并验证了此响应。在有有效响应的情况下，汽车会打开车门。随后，为了启动汽车发动机，钥匙必须出现在汽车内（图2(b)中的内部区域）。在这个区域，钥匙接收不同类型的信息，当回复时，将通知汽车正确的钥匙在汽车内部。然后，汽车将允许启动引擎。需要注意的是，在正常模式下，LF通道只用于从汽车与钥匙通信，因为这样种操作需要大量的能量.</font></p><p><font style="color:#000000;">在备用模式下，例如，当电池耗尽时，用户仍然可以打开并启动他的汽车.制造商通常会在钥匙芯中嵌入一个备用的物理钥匙，以打开车门。这些都如图2(a).所示为了启动发动机，系统使用钥匙的被动LF RFID功能。如前面讨论的，由于非常短的通信范围，用户需要将钥匙放置在汽车中某个预定义的位置附近（例如，汽车启动按钮）。 </font></p><h1 id="sPsBr"><font style="color:#000000;">四、针对 PKES 系统的中继攻击</font></h1><font style="color:#000000;">在上述对于 PKES 系统的研究当中可以发现一点，PKES 系统验证成功只能够打开和启动汽车。</font>**<font style="color:#000000;">它并不会验证正确的信息是否在物理层面真的进行接近</font>**<font style="color:#000000;">。它只会认为有信号发送就认为用户已经接近了。在现实攻防当中，这并不能被认为物理接近的证明。中继攻击并不需要对信号进行解读，也不需要修改信号。只需要接收到完整的信号，接着通过中继器将信号发送到位于目标车辆旁边的设备即可。</font><p><font style="color:#000000;">由于时代发展，PKES 系统也经过了很多种迭代。最基础的 PKES 系统其实本质上是在 RKE 系统上加入了被动的部分。在 125khz&#x2F;13.52mhz 频段下检测到了信号后发送 315mhz&#x2F;415mhz 的信息去解锁车门。还有一种就是现代汽车，利用蓝牙或者 NFC 实现被动检测。这两种中继方案的攻击方式是不一样的。为了方便称呼我们将前者命名为射频中继，后者命名为近场中继</font></p><h1 id="m9V7I"><font style="color:#000000;">五、关于可实现中继攻击的研究方案</font></h1><font style="color:#000000;">根据如上解析，设计一个中继器有两点最基础的要求。</font><ol><li><font style="color:#000000;">首先能够完整的读取并保存钥匙发出的 LF 信号</font></li><li><font style="color:#000000;">能够把 LF 信号完整的传输到另一段设备上</font></li></ol><p><font style="color:#000000;"></font></p><p><font style="color:#000000;">第一套方案：空中中继攻击</font></p><p><font style="color:#000000;">攻击通过一个专门建立的射频链路传递来自汽车的低频信号，以最小的延迟。该链路由发射器和接收器两部分组成。发射器捕获低频信号，并将其上转换为2.5 GHz。获得的2.5 GHz信号然后被放大并通过空气传输。链路的接收部分接收该信号并将其下转换以获得原始低频信号。然后这个LF信号会被再次放大，并发送到一个回路LF天线，该天线会再现汽车发出的完整信号。打开和启动汽车发动机的程序与上述步骤相同。使用模拟上下转换的概念，攻击者可以达到更大的传输&#x2F;接收中继距离，同时保持攻击的大小、功耗和价格都很低。</font></p><p><font style="color:#000000;">第二套方案</font></p><p><font style="color:#000000;">使用一些现有的硬件来搭建中继器设备。我们需要一个读卡器和假的 RFID 标签。但是存在一些问题：调制和解调会很大程度增加攻击响应时间，这就导致中继攻击有可能因为响应时间太长而被发现。第二，由于这种攻击方案会涉及到信号的调制和解调。如果无法找到信号的正确调制方式和解调方式会导致失败。</font></p><p><font style="color:#000000;"></font></p><h2 id="ZDGAl"><font style="color:#000000;">射频中继攻击硬件方案的研究实现</font></h2><font style="color:#000000;">引用自独角兽安全团队的研究</font><p><font style="color:#000000;">首先是整套方案的流程</font></p><p><font style="color:#000000;"></font><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162615937.png"></p><p><font style="color:#000000;">在触摸汽车把手的时候会发出一个 125khz 的信号，来唤醒遥控。设计的设备可以在解调低频信号后接收信号，通过解调后再用 cc1101 发送出去给模块 b。模块 b 再通过这个接收到的信号使用 EM4095  给钥匙传输信号，那么钥匙在接收到信号后会发送一个 315mhz 的信号，这时候模块 b 再接收这个 315mhz 信号后给模块 A 发送信号，模块 A 传输 315mhz 信号给车。完成攻击</font></p><p><font style="color:#000000;">硬件设计方案</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162618732.png"></p><p><font style="color:#000000;">在例子当中的模块 A 和模块 B 是两个不同的设备</font></p><p><font style="color:#000000;">模块 A 使用了 AS3933 接收后再把 125khz 的信号调制放大并通过 CC1101 发送</font></p><p><font style="color:#000000;">模块 b 通过一个 CC1101 模块接收后再用另一个 CC1101 发送</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162621514.png"></p><p><font style="color:#000000;">BQ24170 充电管理</font></p><p><font style="color:#000000;">CC1101 负责解调和调制以及发送信号</font></p><p><font style="color:#000000;">EM4095 读取 RFID 信号</font></p><p><font style="color:#000000;">as3933 转换低频信号为电压值</font></p><p><font style="color:#000000;">atmega3280p 主控芯片</font></p><p><font style="color:#000000;">其实现在来看这个方案有点过时了但是思路还是可以借鉴的。个人认为可以用 PN532 和 ESP32 来代替。 </font></p><p><font style="color:#000000;"></font></p><p><font style="color:#000000;">第二套方案</font></p><p><font style="color:#000000;">这套攻击首先并不只是单纯的中继攻击而是利用了特斯拉 fob 本身的一些漏洞，这里只研究中继方案的实施就不过多赘述。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162625494.png"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162628353.png"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162631091.png"></p><p><font style="color:#000000;">使用两个 proxmark3，一个放在目标身旁，一个放在目标车上。在读取到目标卡信息后通过树莓派上的 yard stick one 发送射频信号完成攻击，这里多加一个外置天线放大信号</font></p><p><font style="color:#000000;">但是这种方法实战中依然会有些问题。首先中继时间会很长，如果目标设备有对延时的检测手段就会失效。第二个，也可能会有 RSSI 检测的问题，所以要想办法再外置一个天线放大信号。这是一套相对来说容易复现的方案但是可泛用性不广</font></p><p><font style="color:#000000;"></font></p><p><font style="color:#000000;"></font></p><h2 id="MuiDR"><font style="color:#000000;">近场中继攻击方案的研究实现</font></h2><font style="color:#000000;">现代汽车在 PKES 的基础上更进一步开发出了</font><font style="color:#000000;">被动进入和启动系统（PEPS，Passive Entry Passive Start)。和传统射频相比，蓝牙和 NFC 的安全程度无疑更高。但是这并不意味着其一点安全问题没有</font><p><font style="color:#000000;"></font></p><h3 id="xkSkk"><font style="color:#000000;">NFC 中继攻击</font></h3><font style="color:#000000;">以下是特斯拉 NFC 卡片解锁车过程简述</font><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162633473.png"></p><p><font style="color:#000000;">我们来看一下这个过程发生了什么事情</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162635715.png"></p><p><font style="color:#000000;">可以看到分成了五个区块</font></p><p><strong><font style="color:#000000;">区块 1：车辆请求智能手机虚拟钥匙的应用标识符 (AID)。</font></strong><font style="color:#000000;"> 车辆首先尝试寻找用于智能手机虚拟钥匙的应用，这是一个常见的智能卡选择应用类型的流程。由于这里使用的是实体 NFC 卡，而不是智能手机，卡片会回应 </font><strong><font style="color:#000000;">“6d00 (无效)”</font></strong><font style="color:#000000;">，表示找不到这个应用标识符。</font></p><p><strong><font style="color:#000000;">区块 2：车辆请求特斯拉 NFC 卡的应用标识符 (AID)。</font></strong><font style="color:#000000;"> 接着，车辆会尝试寻找用于特斯拉实体 NFC 卡的应用标识符。 因为现在使用的是实体卡，卡片会正确回应 </font><strong><font style="color:#000000;">“9000 (有效)”</font></strong><font style="color:#000000;">，表示找到了对应的应用标识符。 车辆收到 “9000” 的响应后，就认为正在和一张特斯拉 NFC 卡进行通信。</font></p><p><strong><font style="color:#000000;">区块 3：车辆发送加密挑战 (Cryptographic Challenge)。</font></strong><font style="color:#000000;"> 在确认卡片是特斯拉 NFC 卡之后，车辆会向卡片发送一个加密挑战，等待卡片对这个挑战做出有效的回应。</font></p><p><strong><font style="color:#000000;">区块 4：等待时间延长 (WTX) 协商。</font></strong><font style="color:#000000;"> 特斯拉 NFC 卡需要时间计算针对车辆挑战的加密响应。 由于计算需要一定的时间（虽然可能只有几毫秒，但对于通信来说仍然可能显得“太久”），卡片会向车辆发送 </font><strong><font style="color:#000000;">“等待时间延长 (WTX)”</font></strong><font style="color:#000000;"> 消息，请求车辆等待，给自己更多的时间来完成计算。 在这段时间里，车辆和卡片之间可能会多次进行这种 WTX 协商。</font></p><p><strong><font style="color:#000000;">区块 5：卡片发送加密响应 (Cryptographic Response)。</font></strong><font style="color:#000000;"> 最终，NFC 卡完成了加密计算，并将计算得到的加密响应发送回车辆。 如果这个响应是有效的，车辆就会解锁车门，并根据车辆的配置，允许用户驾驶汽车。<br></font></p><p><font style="color:#000000;">现在我们已经知道了其工作的原理，接下来就是要实施正式的攻击了。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162638370.png"></p><p><strong><font style="color:#000000;">攻击场景和角色</font></strong></p><p><font style="color:#000000;">这个中继攻击需要</font><strong><font style="color:#000000;">两名攻击者</font></strong><font style="color:#000000;">和一些设备配合完成：</font></p><ul><li><strong><font style="color:#000000;">攻击者 1 (近车端):</font></strong><font style="color:#000000;"> 位于特斯拉车辆旁边，手持 </font><strong><font style="color:#000000;">Proxmark RDV4.0 设备</font></strong><font style="color:#000000;">。Proxmark 设备的作用是模拟特斯拉 NFC 卡，与车辆的 NFC 读卡器进行通信。</font></li><li><strong><font style="color:#000000;">攻击者 2 (近卡端):</font></strong><font style="color:#000000;"> 靠近受害者的特斯拉 NFC 卡片 (或装有特斯拉虚拟钥匙的智能手机)。 攻击者 2 可以使用任何具备 NFC 功能的设备，例如平板电脑、电脑，或者像例子中提到的 </font><strong><font style="color:#000000;">智能手机</font></strong><font style="color:#000000;">。</font></li><li><strong><font style="color:#000000;">受害者:</font></strong><font style="color:#000000;"> 拥有特斯拉 NFC 卡或装有特斯拉虚拟钥匙的智能手机的真实用户，但此时并不知情，也没有主动参与解锁车辆操作。</font></li></ul><p><strong><font style="color:#000000;">通信方式</font></strong></p><p><font style="color:#000000;">为了让两名攻击者协同工作需要建立通信链路。有两种方式：</font></p><ul><li><strong><font style="color:#000000;">蓝牙 (BlueShark 模块):</font></strong><font style="color:#000000;"> Proxmark RDV4.0 可以通过 BlueShark 模块支持蓝牙通信。攻击者 1 的 Proxmark 通过蓝牙与攻击者 2 的智能手机进行通信。</font></li><li><strong><font style="color:#000000;">Wi-Fi (Raspberry Pi):</font></strong><font style="color:#000000;"> 使用 Wi-Fi，攻击者 1 可以将 Proxmark 连接到一个像 Raspberry Pi 这样的小型电脑。Raspberry Pi 通过蓝牙连接 Proxmark，同时通过 Wi-Fi 连接到攻击者 2 的智能手机。</font></li></ul><p><strong><font style="color:#000000;">攻击步骤</font></strong></p><ul><li><strong><font style="color:#000000;">车辆发送 Select AID (选择应用标识符) 请求:</font></strong><font style="color:#000000;"> 当攻击者 1 将 Proxmark 设备靠近车辆 NFC 读卡器时，车辆会首先发送 “Select AID” 请求，询问应用标识符。Proxmark (攻击者 1) 会用正确的值回应车辆，假装自己是合法的特斯拉 NFC 卡。</font></li><li><strong><font style="color:#000000;">Proxmark 接收 Challenge 并转发给攻击者 2 的手机:</font></strong><font style="color:#000000;"> 车辆收到 Proxmark 的正确 AID 响应后，会发送加密挑战 (Challenge)。Proxmark (攻击者 1) 接收到这个 Challenge 后，通过蓝牙或 Wi-Fi 将其转发给攻击者 2 的智能手机。</font></li><li><strong><font style="color:#000000;">攻击者 2 的手机与受害者的 NFC 卡交互，发送 Challenge:</font></strong><font style="color:#000000;"> 攻击者 2 的智能手机接收到 Challenge 后，通过 NFC 与受害者的特斯拉 NFC 卡 (或智能手机) 进行通信。 智能手机会选择正确的 AID，并将从 Proxmark 收到的 Challenge 发送给受害者的 NFC 卡。 （本质上，攻击者 2 的手机在模仿车辆，向真正的 NFC 卡请求响应）</font></li><li><strong><font style="color:#000000;">受害者的 NFC 卡计算并响应加密响应，转发给 Proxmark:</font></strong><font style="color:#000000;"> 受害者的特斯拉 NFC 卡接收到 Challenge 后，会进行加密计算，生成加密响应 (Crypto Response)。这个加密响应会通过 NFC 发送回攻击者 2 的智能手机，然后智能手机再通过蓝牙或 Wi-Fi 将响应转发回给 Proxmark (攻击者 1)。</font></li><li><strong><font style="color:#000000;">Proxmark 将加密响应发送给车辆:</font></strong><font style="color:#000000;"> Proxmark (攻击者 1) 接收到来自攻击者 2 转发的加密响应后，会将这个合法的加密响应发送给车辆的 NFC 读卡器。</font></li></ul><p><font style="color:#000000;"></font></p><p><font style="color:#000000;">我们可以研究一下 这个过程底层代码是如何工作的</font></p><p><font style="color:#000000;">代码首先进行初始化设置，包括 Proxmark 硬件和的配置。将 Proxmark 设置为 14443 卡模拟模式，使其能够模拟 NFC 卡的行为。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162642070.png"></p><p><font style="color:#000000;">Proxmark 使用 </font><code>&lt;font style=&quot;color:#000000;&quot;&gt;GetIso14443aCommandFromReader()&lt;/font&gt;</code><font style="color:#000000;"> 函数 </font><strong><font style="color:#000000;">接收来自车辆 NFC 读卡器的数据</font></strong><font style="color:#000000;">。通过 </font><code>&lt;font style=&quot;color:#000000;&quot;&gt;usarT_rxdata_available()&lt;/font&gt;</code><strong><font style="color:#000000;">检查 UART 端口</font></strong><font style="color:#000000;"> (用于蓝牙芯片) 是否有可用数据，目的是检查是否接收到来自智能手机的数据。如果蓝牙端口有数据，Proxmark 会先</font><strong><font style="color:#000000;">向车辆发送一个最后的 WTX (等待时间延长) 消息</font></strong><font style="color:#000000;">并且</font><strong><font style="color:#000000;">读取通过蓝牙接口接收的数据</font></strong><font style="color:#000000;">。 这样能够保证蓝牙接收的数据是来自受害者卡片的 </font><strong><font style="color:#000000;">加密响应 (crypto response)</font></strong><font style="color:#000000;">。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162644111.png"></p><p><font style="color:#000000;">然后 会处理通过 NFC 接收到的数据，</font><font style="color:#000000;">首先检查数据的前几个字节</font><font style="color:#000000;">，以判断 </font><font style="color:#000000;">NFC 消息的类型</font><font style="color:#000000;">，特别是处理通信早期阶段的 </font><font style="color:#000000;">底层 NFC 消息</font><font style="color:#000000;">。  </font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162646548.png"></p><p><font style="color:#000000;">如果它只是接收应用层消息（apdu），代码也会处理这些消息：</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162649150.png"><font style="color:#000000;"></font></p><p><font style="color:#000000;">当从车辆读卡器接收到challenge后，需要将这个challenge转发给攻击者 2 的智能手机。代码会将接收到的challenge数据 复制到缓冲区当中，然后通过 UART 接口发送到蓝牙芯片，由蓝牙芯片将数据传输给智能手机。智能手机上的应用程序将负责处理接收到的challenge数据。一旦通过蓝牙接收到加密响应，就通过NFC将其发送给车辆的读卡器。<br></font><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162652408.png"></p><p><font style="color:#000000;"> 在通过 NFC 发送数据之前，Proxmark 上需要进行一些准备工作： 添加 CRC 校验字节 (CRC bytes)，确保数据传输的完整性。使用 </font><code>&lt;font style=&quot;color:#000000;&quot;&gt;prepare_tag_modulation()&lt;/font&gt;</code><font style="color:#000000;"> 函数进行调制。使用 </font><code>&lt;font style=&quot;color:#000000;&quot;&gt;EmSendPrecompiledCmd()&lt;/font&gt;</code><font style="color:#000000;"> 函数 通过 NFC 发送数据。但还需要创建额外的代码来在第二个攻击者的智能手机上运行，该手机离受害者的特斯拉NFC卡很近。该应用程序需要NFC、蓝牙和Wi-Fi功能才能执行中继攻击。</font></p><p><font style="color:#000000;">当第二个攻击者的智能手机上运行的Android应用程序通过Wi-Fi或蓝牙接收到来自Proxmark的challenge时，它会通过NFC将该 challenge 转发给受害者的卡，然后读取加密响应并将其发送回Proxmark。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162655838.png"><font style="color:#000000;"><br></font></p><p><font style="color:#000000;"></font></p><h3 id="kls01"><font style="color:#000000;">蓝牙中继攻击</font></h3><font style="color:#000000;">近距离身份验证系统：这种系统的目的是当可信对象在附近时进行身份验证。通过可行对象与设备无线通信实现。无钥匙进入系统是技术最常见最明显的应用。类似的技术也用于智能锁，建筑访问控制系统</font><p><font style="color:#000000;"></font></p><p><strong><font style="color:#000000;">蓝牙距离测量方法</font></strong></p><p><font style="color:#000000;">蓝牙通过维持 ble 连接和通信的能力来推断临近，同时保持在合理的延迟范围内。旧版本蓝牙不提供任何基于 TOF 和三角测距的测距方法。它的距离由 RSSI 或 AOA 测定。很容易收到中继攻击。并且存在大量的设备使用 BLE 进行近距离身份验证</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162658176.png"></p><p><font style="color:#000000;">一个最简单的中继攻击模型。只需要将中继过来的信号进行放大。这样车辆的 RSSI 值会变大这样就会认为信号源就在旁边</font></p><p><strong><font style="color:#000000;">BLE 的中继攻击</font></strong></p><p><font style="color:#000000;">GATT 中继攻击</font></p><ul><li><font style="color:#000000;">Gattacker </font><a href="https://github.com/securing/gattacker"><font style="color:#1DC0C9;">https://github.com/securing/gattacker</font></a></li><li><font style="color:#000000;">Btlejuice </font><a href="https://github.com/DigitalSecurity/btlejuice"><font style="color:#1DC0C9;">https://github.com/DigitalSecurity/btlejuice</font></a></li></ul><p><font style="color:#000000;">HCL 中继</font></p><ul><li><font style="color:#000000;">mirage </font><a href="https://github.com/RCayre/mirage"><font style="color:#1DC0C9;">https://github.com/RCayre/mirage</font></a></li></ul><p><font style="color:#000000;">PHY 中继</font></p><ul><li><font style="color:#000000;">analog 中继 </font><a href="https://arxiv.org/abs/2202.06554"><font style="color:#1DC0C9;">https://arxiv.org/abs/2202.06554</font></a></li></ul><p><font style="color:#000000;">攻击限制</font></p><p><font style="color:#000000;">gatt 中继攻击的延迟很明显，不支持未知LTK的链路层加密</font></p><p><font style="color:#000000;">hcl 中继攻击 不支持未知LTK的链路层加密，</font></p><p><font style="color:#000000;">phy 中继攻击 受距离影响比较大</font></p><p><font style="color:#000000;">因此 我们可以通过在链路层转发PDU来结合HCI和模拟继电器的许多优点，同时避免它们的缺点。</font></p><p><strong>链路层数据包结构</strong></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250318162701474.png"></p><p><font style="color:#000000;">蓝牙链路层报文由以下字段组成</font></p><ol><li><font style="color:#000000;">Preamble(前导码）：1 到 2 个字节，用于同步接收端</font></li><li><font style="color:#000000;">Access Address（接入地址）：占 4 个字节，用于识别特定的连接</font></li><li><font style="color:#000000;">PDU（协议数据单位）：占 2-258 字节。包含由具体的链路层数据。由 header 和 payload 组成。header 占用 2 个字节，包含一些控制信息。payload 占用 1-255 字节，包含具体的数据信息</font></li><li><font style="color:#000000;">CRC：3 个字节，用于验证数据完整性</font></li></ol><p><strong><font style="color:#000000;">在蓝牙建立连接的时候会有一个 CONNECT_IND PDU 的发送，通过这些参数后主机从机才能建立连接。</font></strong></p><p><font style="color:#000000;"></font></p><p><strong><font style="color:#000000;">链路层蓝牙劫持的细节</font></strong></p><p><font style="color:#000000;">在基础知识部分我们有提到 BLE 建立连接依赖的是 CONNECT_IND 那么劫持的关键就是如何去修改这个 CONNECT_IND.</font></p><p><font style="color:#000000;">接下来是一些参数的获取方法：</font></p><ul><li><font style="color:#000000;">获取Access Address 和 CRCInit：直接在空中包中获取或者推算。接入地址可以从空中包获取，空包计算 CRCinit(CRC24 算法）</font></li><li><font style="color:#000000;">获取 Channel Map：枚举 BLE 链路所使用的所有信道（监听同一个频道，每一个频道停留 4 秒，总耗时 4*37 &#x3D; 148s</font></li><li><font style="color:#000000;">获取 Conenction interval：信道切换时间。跳频算法#1：Fn+1 &#x3D;（ Fn + hop ）mod 37 。找一个合适的channel，监听两次报文的间隔时间处以37</font></li><li><font style="color:#000000;">获取Hop Increment ：跳频参数，数据信道选择算法中使用。范围是5-16的随机值，测试所有的可能值</font></li></ul><p><font style="color:#000000;"></font></p><p><font style="color:#000000;">劫持的关键在 </font><strong><font style="color:#000000;">supervision timeout 机制</font></strong><font style="color:#000000;">，原理其实类似于滚动码系统当中的ROLLJAM</font></p><p><font style="color:#000000;"></font></p><p><strong>Supervision Timeout 机制的利用</strong>：</p><p><font style="color:#000000;">Supervision Timeout 是 BLE 连接的一个超时机制，规定了主从设备之间在一段时间内没有数据传输就会自动断开连接。攻击者利用这一点，通过阻断（干扰）主从设备之间的信号，使得两者在指定的时间内没有成功通信，导致超时断开。</font></p><p><strong>信号干扰</strong><font style="color:#000000;">：</font></p><p><font style="color:#000000;">攻击者通过阻断主设备和从设备的通信，迫使连接出现延迟，无法在规定的时间内完成必要的握手和数据交换。绿色的箭头表示正常的通信，而红色的箭头代表被攻击者阻断的信号。</font></p><p><strong>超时断开连接</strong><font style="color:#000000;">：</font></p><p><font style="color:#000000;">当信号被攻击者持续阻断，超时机制触发，主设备（Master）会主动发送一个 </font><strong>LL_TERMINATE_IND</strong><font style="color:#000000;"> 指令，从而断开当前的连接。这意味着从设备（Slave）失去了原始主设备的连接，可以被攻击者利用，以重新连接或接管。</font></p><p><strong>攻击者的劫持</strong><font style="color:#000000;">：</font></p><p><font style="color:#000000;">在主设备断开与从设备的连接后，攻击者可以尝试与从设备重新建立连接，从而实现对该连接的劫持。通过利用这种机制，攻击者可以有效地将原本的连接转移到自己控制的设备上。</font></p><p><font style="color:#000000;"></font></p><p><font style="color:#000000;"></font></p><h1 id="twFHU"><font style="color:#000000;">六、参考资料</font></h1><font style="color:#000000;">D2T2 - Chasing Cars: Keyless Entry System Attacks - Yingtao Zeng, Qing Yang and Jun Li</font><font style="color:#1DC0C9;">(</font>[<font style="color:#1DC0C9;">https://www.youtube.com/watch?v=rhm1TiFJc7s</font>](https://www.youtube.com/watch?v=rhm1TiFJc7s)<font style="color:#1DC0C9;">)</font><p><font style="color:#000000;">Lennert Wouters - Passive Keyless Entry and Start Systems - DEF CON 27 Car Hacking Village(</font><a href="https://www.youtube.com/watch?v=tFUdQJkKsLU&t=729s"><font style="color:#1DC0C9;">https://www.youtube.com/watch?v=tFUdQJkKsLU&amp;t=729s</font></a><font style="color:#1DC0C9;">)</font></p><p><a href="https://www.theverge.com/2022/9/12/23348765/tesla-model-y-unlock-drive-car-thief-nfc-relay-attack"><font style="color:#1DC0C9;">https://www.theverge.com/2022/9/12/23348765/tesla-model-y-unlock-drive-car-thief-nfc-relay-attack</font></a></p><p><font style="color:#000000;">Bluetooth LE Link Layer Relay Attacks by Sultan Qasim Khan | hardwear.io NL 2022（</font><a href="https://www.youtube.com/watch?v=2CvHM5gZVnY"><font style="color:#1DC0C9;">https://www.youtube.com/watch?v=2CvHM5gZVnY</font></a><font style="color:#000000;">）</font></p><p><font style="color:#000000;"></font></p>]]></content>
    
    
    <summary type="html">车联网安全之PKES到PEPS中继攻击方案实现研究
</summary>
    
    
    
    <category term="car-hacking" scheme="https://ch0en3.github.io/categories/car-hacking/"/>
    
    
    <category term="car-hacking" scheme="https://ch0en3.github.io/tags/car-hacking/"/>
    
  </entry>
  
  <entry>
    <title>车联网安全之滚动码系统研究</title>
    <link href="https://ch0en3.github.io/2025/03/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E4%B9%8B%E6%BB%9A%E5%8A%A8%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6/"/>
    <id>https://ch0en3.github.io/2025/03/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E4%B9%8B%E6%BB%9A%E5%8A%A8%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6/</id>
    <published>2025-03-15T16:58:33.619Z</published>
    <updated>2025-03-16T03:13:34.646Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发自先知社区<a href="https://xz.aliyun.com/news/17201">https://xz.aliyun.com/news/17201</a></p><h1 id="k9oqU">一.研究背景</h1><h2 id="vvkce">浅析汽车钥匙系统</h2><h3 id="zLSvU">前言</h3><p><font style="color:rgb(43, 56, 53);">从无线遥控无钥匙进入 (RKE) 系统开始，到功能更强大的被动式进入系统 (PEK)和被动进入&#x2F;被动启动(PEPS)，再到被动式安全进入系统 (PASE)。无钥匙进入系统在过去 40 年里得到了迅猛发展。</font><font style="color:rgb(43, 43, 43);">它从一种技术跳到另一种技术，从简单的 ASK、FSK 调制到蓝牙低功耗（BLE）系统中的编码跳频扩频，再到超宽带（UWB）调制。同样，在安全领域，从简单的无编码数字技术到编码数字技术、滚动编码和高级加密标准（AES）的实施，使这项技术达到了更高的安全水平。</font></p><h3 id="6fff77c9"><font style="color:rgb(43, 56, 53);">遥控钥匙（RKE，Remote Keyless Entry）</font></h3>**工作原理**<font style="color:rgb(43, 56, 53);">：</font><ol><li><strong>发送信号</strong><font style="color:rgb(43, 56, 53);">：当用户按下遥控钥匙上的按钮时，遥控器会发送一个无线电频率（RF）信号。这个信号包含了特定的识别码，用于与车辆进行匹配。</font></li><li><strong>接收信号</strong><font style="color:rgb(43, 56, 53);">：车辆上的接收器接收到这个RF信号，并解析其中的识别码。</font></li><li><strong>验证信号</strong><font style="color:rgb(43, 56, 53);">：如果识别码与车辆预先存储的识别码匹配，接收器会发送信号到车载控制单元（ECU）。</font></li><li><strong>执行指令</strong><font style="color:rgb(43, 56, 53);">：ECU执行相应的动作，比如解锁车门、锁定车门或打开行李箱。</font></li></ol><p><strong>技术</strong><font style="color:rgb(43, 56, 53);">：</font></p><ul><li><font style="color:rgb(43, 56, 53);">使用RF信号，一般工作在315 MHz或433 MHz频段。</font></li><li><font style="color:rgb(43, 56, 53);">采用滚动码技术防止信号被拦截和复制</font></li></ul><p><font style="color:rgb(43, 43, 43);">作为 PEPS 的前身，RKE 通过钥匙扣向与汽车 BCM（车身控制模块）相连的射频接收器发射 UHF（超高频）信号，以验证用户身份。一旦身份得到验证，系统将执行由 BCM 驱动的开门&#x2F;关门动作。如图所示，这种单向验证机制可以验证预设密码。如果密码正确，他或她就会被允许进入。</font></p><p><font style="color:rgb(43, 43, 43);"></font></p><h3 id="fd1c6730"><font style="color:rgb(43, 56, 53);">被动进入系统（PKE，Passive Keyless  Entry）</font></h3>**工作原理**<font style="color:rgb(43, 56, 53);">：</font><ol><li><strong>信号发送</strong><font style="color:rgb(43, 56, 53);">：车辆会周期性地发送低频（LF）信号，这个信号的范围一般在1-3米以内。</font></li><li><strong>钥匙响应</strong><font style="color:rgb(43, 56, 53);">：当携带钥匙的用户进入这个范围时，钥匙会接收到车辆的LF信号并响应，发送一个高频（HF）信号回给车辆。</font></li><li><strong>验证信号</strong><font style="color:rgb(43, 56, 53);">：车辆接收到钥匙的HF信号，并解析其中的识别码。</font></li><li><strong>执行指令</strong><font style="color:rgb(43, 56, 53);">：如果识别码匹配，车辆会自动解锁车门。</font></li></ol><p><strong>技术</strong><font style="color:rgb(43, 56, 53);">：</font></p><ul><li><font style="color:rgb(43, 56, 53);">使用LF信号进行近距离通信（125 kHz）。</font></li><li><font style="color:rgb(43, 56, 53);">HF信号用于远距离通信（通常是RF信号，315 MHz或433 MHz）。</font></li><li><font style="color:rgb(43, 56, 53);">使用双向认证和加密技术提高安全性。</font></li></ul><p><font style="color:rgb(43, 43, 43);">到 21 世纪初，人们将 RKE 的单向验证机制升级为称为 PKE（被动式无钥匙进入）系统的双向机制，验证不再由钥匙持有者（即驾驶员）启动，而是由车上连接到 BCM 的低频发射器启动。车门关闭并上锁后，车内的无线模块将持续发射低频（125KHz）信号，寻找一定范围内的应答器（内置在钥匙扣中）。当模块找到应答器时，其代码将唤醒应答器。如果模块的低频部分长时间没有收到反馈信号，它就会进入睡眠模式，以降低功耗。每当钥匙扣中的应答器接收到唤醒信号时，它就会通过高频（即 433MHz）信号发送滚动编码数据报。内置模块解码并理解数据报后，将指示汽车执行某些操作。由此可见，与 RKE 相比，PKE 采用的验证机制是双向的。</font></p><h3 id="edfd47be"><font style="color:rgb(43, 56, 53);">被动进入和启动系统（PEPS，Passive Entry Passive Start）</font></h3>**工作原理**<font style="color:rgb(43, 56, 53);">：</font><ol><li><strong>进入车辆</strong><font style="color:rgb(43, 56, 53);">：</font><ul><li><font style="color:rgb(43, 56, 53);">工作原理与PKE 相同，车辆会发送LF信号，钥匙响应并发送HF信号，车辆验证并解锁车门。</font></li></ul></li><li><strong>启动车辆</strong><font style="color:rgb(43, 56, 53);">：</font><ul><li><font style="color:rgb(43, 56, 53);">当用户进入车内并按下启动按钮时，车辆会再次发送LF信号以确认钥匙是否在车内。</font></li><li><font style="color:rgb(43, 56, 53);">钥匙响应并发送HF信号，车辆验证识别码。</font></li><li><font style="color:rgb(43, 56, 53);">如果识别码匹配，车辆的ECU允许启动引擎。</font></li></ul></li></ol><p><strong>技术</strong><font style="color:rgb(43, 56, 53);">：</font></p><ul><li><font style="color:rgb(43, 56, 53);">结合PEK的所有技术。</font></li><li><font style="color:rgb(43, 56, 53);">通过车辆内的多个天线阵列实现更精确的钥匙定位，确保钥匙在车内时才能启动引擎。</font></li></ul><p><font style="color:rgb(43, 43, 43);">PEPS 是一种安全的无线通信系统，可使驾驶员在不使用钥匙的情况下进入汽车，解锁汽车并启动发动机。该系统使用射频信号，通过在汽车和钥匙之间发送信号来验证钥匙。PEPS 系统使用低频无线电波（通常为 125 千赫或 134 千赫）和超高频（UHF）无线电波（通常为 1 千兆赫以下的信号）进行双向通信，在钥匙和汽车之间交换唯一的钥匙访问代码。一旦交换的代码符合预期值，且钥匙在汽车附近，汽车就会允许驾驶员进入。系统还会测量汽车与钥匙之间的距离，以确定钥匙是在车内还是车外。这一信息可用于为驾驶员提供不同类型的访问权限。例如，如果钥匙在车外，则只允许进入车内，但发动机启动功能将不起作用。基本上，目前主流的 PEPS 都已集成了 NFC 和蓝牙功能。驾驶员可将 NFC 手机放在汽车 B 柱附近，然后进入车内。这消除了将钥匙扣和智能手机都放进口袋的麻烦。但将蓝牙引入 PEPS 则更具革命性。蓝牙的高频率、跳频机制和强化的安全机制与 UHF&#x2F;LF 的保证机制相比，提供了更多的安全保证。此外，蓝牙的测距和定位功能对掌握开关门的时机大有帮助。蓝牙测距和定位的精度可达半米或一米。它包括 RSSI 方法和 AoA 方法。前者精度较低，可达到 1 至 5 米的精度水平。后者精度更高，精度可达半米。</font></p><h3 id="8fcda306"></h3><h1 id="bRzv6">二.滚动码机制</h1>虽然汽车无钥匙进入系统已经发展了很多年，但是采用 RKE 依然大量存在。并且，由于滚动码机制的特殊性。在现如今依然存在大量使用滚动码的地方。因此，研究滚动码机制依然是非常有价值和意义的。<p>应用滚动码技术意味着每一个键的fob信号传输都是唯一的，即它随着每按一个按钮而变化。唯一性是通过在钥匙中心（以及在接收时的车辆中）增加一个16位宽计数器来实现的。如果两边的计数器都同步，则按下按钮有效。然后，每个方增加其计数器以同步按下以下按钮。因此，如果攻击者捕获了从钥匙中心发送的有效信号，并由车辆用计数器Ck &#x3D; n接收并重放它，它将被车辆中的接收器丢弃，作为其计数器Cv &gt; Ck，即Cv&#x3D;（n+&#x3D;）：k&gt;0。</p><p>另一方面，当钥匙扣超出车辆范围时，需要按下按钮，即使用钥匙扣来锁定&#x2F;解锁汽车和Ck &gt; Cv。这些情况被进一步分为两个不同的操作窗口</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010253895.webp">        </p><h3 id="2c60edda">单一窗口</h3>**单一窗口**是指计数器差值 _<font style="color:rgb(0,0,0);">Cdif f </font>_<font style="color:rgb(0,0,0);">= </font>_<font style="color:rgb(0,0,0);">Ck − Cv</font>_ 较小的情况。具体来说，当差值小于16时（即 _<font style="color:rgb(0,0,0);">Cdif f < </font>_<font style="color:rgb(0,0,0);">16</font>），系统可以在第一次按键按下时立即进行同步。这意味着当车辆接收到钥匙扣的信号后，它会立即更新自己的计数器，与钥匙扣的计数器保持一致，不需要额外的步骤。<p><strong>主要特点：</strong></p><ul><li><strong>同步快速</strong>：只需一次按键操作。</li><li><strong>差值较小</strong>：差值在16以内，车辆可以轻松同步。</li><li><strong>即时更新</strong>：车辆会立即更新其计数器，丢弃在这之前所有未接收到的代码。</li></ul><h3 id="8ede463a">重新同步/双窗口</h3>**重新同步/双窗口**是指计数器差值较大的情况。具体来说，当差值在<font style="color:rgb(0,0,0);">16 </font>_<font style="color:rgb(0,0,0);">< Cdif f < </font>_<font style="color:rgb(0,0,0);">2 15</font>时，系统需要进行重新同步。<p><strong>主要特点：</strong></p><ul><li><strong>同步需要两次按键操作</strong>：当车辆接收到一次信号时，暂时存储这个信号并等待下一次信号。如果下一次信号的计数器值比上次大1，则系统进行同步。</li><li><strong>差值较大</strong>：差值在16到<font style="color:rgb(0,0,0);">2 15</font>之间，车辆需要额外的验证步骤来确保安全。</li><li><strong>双步验证</strong>：车辆需要接收到两次连续的信号才能完成同步，从而提高了安全性，防止信号被重放攻击。</li></ul><p>如果上述任何一个失败，则车辆接收到的钥匙焦点信号被丢弃。此外，请注意，由于底层的加密机制即使是一位信息的变化（例如，计数器增量）也会导致最终传输信号的显著变化。因此，攻击者通过捕获上一个信号来推断下一个有效的解锁信号，这在计算上是不可行的。</p><p>请注意，当钥匙 fob 已经发出信号时，已发送的代码也可以被认为未使用，但车辆没有收到它。例如，当解锁按钮被意外按下时。（由图1a中的“解锁代码n+2”和“n+3”描述）。**为了避免不同步，从而在这种情况下将我们自己锁在我们的车辆之外，基于滚动代码的系统提供了一个安全功能，允许钥匙fob的计数器比车辆的计数器领先一步。**这是通过在车辆上维护的不是一组，而是一组有效的“未来代码”来实现的 。如果从钥匙fob接收到的代码与这些未来的代码匹配，车辆将重新同步到最后一个钥匙fob信号中的代码，并使该集合中所有以前（但未使用的）代码失效（参见图中的“解锁代码n+4”）。<strong>显然，如果攻击者可以获得这些未使用的未来代码之一（即，捕获汽车附近的意外按钮按下的信号），并且她可以在车主再次使用钥匙fob之前重播它，攻击者可以访问车辆</strong>。然而，在实践中获取这些未来的代码是极其困难的，特别是当攻击者想要瞄准一个随机的受害者时。这就是为什么这种安全配置被认为是一个方便的特性，使关键的fob使用无缝和更少的麻烦</p><h1 id="tpDwp">三.rollback 与 rolljam 工作机制探讨</h1>虽然理论上滚动码机制是一项安全的技术。但是在 2015 年一种名为 rolljam 的技术证明了基于滚动码的密钥系统是极易破坏的。简而言之，根据 rolljam 的原理破解滚动码系统只需要三个步骤：干扰，捕捉，重放.<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010257869.webp"></p><p>如上图 rolljam 部分的流程图所示，它分为四个步骤</p><ol><li>时刻捕捉信号</li><li>采用特定设备干扰车辆与钥匙的正常通信</li><li>因为干扰，从而引诱车主第二次发送解锁信号</li><li>重放先前捕获的第一次信号</li></ol><p>回顾一下这整个过程是怎么实现的。首先我们拥有一个可以实现干扰，捕捉，重放的设备。在攻击模型当中，受害者由于步骤三会按下两次解锁按钮。同时我们会得到两个滚动码，此时我们再重放第一次接收到的滚动码就可以攻击成功。为什么这个滚动码是有效的？还记得在上面的滚动码原理吗。由于滚动码是一次性的且必须按顺序使用，拦截并阻止一个滚动码后，合法用户的遥控器会发送下一个滚动码。这导致接收设备并没有意识到有一个滚动码已经被阻塞并存储下来。钥匙发送的信号并没有被车辆所接收到，这在滚动码设计当中是被允许的。因此，这个接收到的滚动码被判定为有效。攻击成功。</p><p>但是这样的作法存在很大的缺点：</p><ol><li>首先在这个攻击模型当中阻塞的作用非常关键。倘若阻塞装置不能很好的阻塞合法信息的通信，我们所收集到的滚动码会因此作废。这就导致了对阻塞装置的放置有很高的要求</li><li>与条件一类似。必须在收集信号完成后及时的使用它。否则它会随着滚动的信号更新而失效，整个攻击流程必须从头开始</li></ol><p>针对 rolljam 的以上缺点另外一种名为 rollback 的机制被提出。顾名思义它叫做回滚，利用的便是滚动码当中的回滚机制。在不同的 RKE 系统当中回滚系统都不同。但是存在回滚机制的系统原理都是当<strong>多个已经连续被发送过的滚动码被重新发送</strong>，这个时候滚动码系统认为自身出现了错误，从而回滚到之前的已经被使用过的滚动码。这个过程如上图中右图所示。与 rolljam 的工作步骤类似：</p><ol><li>时刻捕捉信号</li><li>采用特定设备干扰车辆与钥匙的正常通信</li><li>因为干扰，从而引诱车主第二次发送解锁信号</li></ol><p>然而我们并不需要第四个步骤，因为回滚机制的存在。我们可以在任意时间重放这个滚动码,这个滚动码都有效。</p><h1 id="X0O1Z">四.基于 esp32 的 rollback 与 rolljam 攻击原理的 CTF 题目</h1><h4 id="a0PWI">硬件部分</h4>esp32+cc1101 x2<p>一个 SDR(RTL-SDR 即可</p><p>rolljam 和 rollback 设备，这里使用的是自制的 EvilcrowRF</p><h4 id="rnHpL">软件部分</h4>[https://github.com/ch0en3/rollback-rolljam_ctf]<p>感兴趣的师傅可以玩一下</p>]]></content>
    
    
    <summary type="html">滚动码系统研究
</summary>
    
    
    
    <category term="car-hacking" scheme="https://ch0en3.github.io/categories/car-hacking/"/>
    
    
    <category term="car-hacking" scheme="https://ch0en3.github.io/tags/car-hacking/"/>
    
  </entry>
  
  <entry>
    <title>一次无线电分析经历</title>
    <link href="https://ch0en3.github.io/2025/03/%E4%B8%80%E6%AC%A1%E6%97%A0%E7%BA%BF%E7%94%B5%E5%88%86%E6%9E%90%E7%BB%8F%E5%8E%86/"/>
    <id>https://ch0en3.github.io/2025/03/%E4%B8%80%E6%AC%A1%E6%97%A0%E7%BA%BF%E7%94%B5%E5%88%86%E6%9E%90%E7%BB%8F%E5%8E%86/</id>
    <published>2025-03-15T16:58:09.515Z</published>
    <updated>2025-03-15T17:28:21.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nL9lG">利用URH的步骤</h3><ol><li>记录信号</li><li>信号说明</li><li>信号分析</li></ol><p>首先找到通过URH自带的频谱分析器寻找到系统通信的中心频率。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011842426.png"></p><p>找到中心频率后利用记录信号工具捕获信号。urh可以记录从sdr中捕获的原始音频信号。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011844967.png"></p><p><font style="color:rgb(13, 13, 13);">过放大捕获的音频信号并观察清晰的正弦波形以及非平凡的模式，可以验证捕获很可能是正确的</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011847379.png"></p><p>一旦信号被捕获到就可以利用URH的发送信号工具进行重播</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011849682.png"></p><h2 id="w1KdN">逆向工程RF协议</h2><font style="color:rgb(13, 13, 13);">所讨论的系统使用 RF 信号在设备之间进行无线通信。这些无线电波用于在每个设备之间传输二进制数据，即 0 和 1。通过无线电波传输二进制数据的过程称为调制 。</font><p><font style="color:rgb(13, 13, 13);">有三种主要的简单调制二进制信号的方式：幅度键控 (ASK)、频率键控 (FSK) 和相位键控 (PSK)。它们分别产生不同的波形，可以很容易地通过视觉识别。如图所示。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011852263.png"></p><p><font style="color:rgb(13, 13, 13);">每种技术都使用正弦波的不同属性来分别编码零和一。幅度键控 (ASK) 使用波的振幅，其中较高的振幅通常编码为 1，较低的振幅编码为 0。频率键控 (FSK) 则保持振幅和相位不变。而是在两个不同的频率之间进行切换以区分 0 和 1。最后，相位键控 (PSK) 使用相位变化来区分这两个符号。</font></p><p><font style="color:rgb(13, 13, 13);">解调是将调制信号转换回原始二进制数据的过程。在 RF 通信的大多数实际应用中，这是直接在硬件中完成的，使用专门的无线电接收器和电路自动将信号转换回二进制数据 。通常，该硬件还实现了错误校正、噪声过滤和其他技术，以增加通信的可靠性，因为干扰和其他干扰在现实世界中是不可避免的。</font></p><p><font style="color:rgb(13, 13, 13);"></font></p><p><font style="color:rgb(13, 13, 13);">urh可以自动解调，但是很多时候无法找到正确的调制参数。因此我们可以使用audacity进行手动解调。</font></p><p><font style="color:rgb(13, 13, 13);">解调的步骤如下：</font></p><ol><li><font style="color:rgb(13, 13, 13);">将 URH 捕获的原始信号数据通过菜单选项文件 - 导入 - 原始数据导入到 Audacity 中。URH 将信号保存为有符号 8 位字节的原始 IQ 数据。通过选择编码为有符号 8 位 PCM 的 2 通道 (立体声)，可以将数据的 I 和 Q 组件分开并导入到两个单独的轨道中。在这种情况下，仅使用其中一个足以提取信息。因此，在 Audacity 中，将立体声轨道拆分为两个单声道轨道，然后删除第二个轨道。导入选项的其余部分并不重要。</font></li><li><font style="color:rgb(13, 13, 13);">其次，记录 Audacity 感知到的中心频率。可以通过菜单选项分析 - 绘制频谱来找到这一点。注意，由于样本率等多个特征不是原始信号数据的一部分，因此此频率可能不等于实际的 868.64 MHz 的中心频率。在下面的步骤中使用了这个频率。</font></li><li><font style="color:rgb(13, 13, 13);">对第一个轨道应用高通滤波器，并对第二个轨道应用低通滤波器，将滚降值设置为 48 dB。前者基本上将较高的频率映射到输出波中的较高振幅，后者则相反。</font></li><li><font style="color:rgb(13, 13, 13);">使用 Audacity 的脚本语言 Nyquist 对每个轨道应用绝对值。使用了简短的 Nyquist 程序 (s-abs </font><em><font style="color:rgb(13, 13, 13);">track</font></em><font style="color:rgb(13, 13, 13);">) 来实现。然后对两个轨道应用了低通滤波器，计算了信号的包络。最后，对最初应用了低通滤波器的轨道进行了反转。这意味着现在两个轨道分别对应于原始信号的高频和低频部分。</font></li><li><font style="color:rgb(13, 13, 13);">接下来，将两个轨道混合到一起形成一个新轨道，即将信号相加。</font></li><li><font style="color:rgb(13, 13, 13);">将混合轨道放大到尽可能高的程度，并启用剪切，以创建一个二进制信号。这创建了最终信号，即从原始信号解调出的原始二进制信号。</font></li><li><font style="color:rgb(13, 13, 13);">最后，将最终的二进制波形导出为原始数据到文件中。通过选择最终轨道并使用菜单选项文件 - 导出 - 导出所选音频 来完成。在随后的文件对话框中，选择”其他未压缩文件”作为类型，并选择无标题 (例如 RAW)，并选择有符号 8 位 PCM 编码。这样就可以将信号导出为原始二进制振幅数据，表示为有符号字节。</font></li></ol><p><font style="color:rgb(13, 13, 13);"></font></p><p><font style="color:rgb(13, 13, 13);">这就是解调信号的过程</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011854887.png"></p><p>经过此过程的结果是一个二进制波形而不是一段实际的二进制数据,因此编写了一个简单的python程序用于提取</p><pre><code class="language-c">import matplotlib.pyplot as pltSIGNAL_LEN, SYMBOL_LEN = 34000, 200FILE, SIGNAL_OFFSETS = &quot;door-signal.raw&quot;, [1800, 856160, ...]with open(FILE, &quot;rb&quot;) as f:signal = [b if b &lt; 128 else b - 256 for b in f.read()]for i, offset in enumerate(SIGNAL_OFFSETS):xs = range(offset, offset + SIGNAL_LEN, SYMBOL_LEN)plt.scatter(xs, [0 for _ in xs], c=&quot;red&quot;)bits = &quot;&quot;.join([&#39;1&#39; if signal[x] &gt; 0 else &#39;0&#39; for x in xs])print(f&quot;Packet &#123;str(i).ljust(2)&#125; =&quot;, hex(int(bits, 2)))plt.plot(signal)plt.show()</code></pre><p><font style="color:rgb(13, 13, 13);">该程序期望一个 x 轴偏移值列表，其中包含信号的第一个比特位。这些值是手动找到的，通过手动查看程序创建的图来实现。信号长度和符号长度也是手动测量的，但这些对于所有捕获的信号来说是恒定的。只需手动推导出每个信号的信号起始偏移量，这相当耗时。因此，这个过程仅应用于少数信号，直到收集到足够的信息来对协议做出结论。</font></p><p><font style="color:rgb(13, 13, 13);"></font></p><p><font style="color:rgb(13, 13, 13);">通过使用 Audacity 和描述的方法，从每个记录的信号中提取了二进制数据。这些数据以十六进制形式呈现在表中。分析数据后可以看到一个非常清晰的结构。所有记录的信号解码后都恰好为 170 位，并且始终具有以下结构。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011858946.png"></p><ol><li><font style="color:rgb(42, 43, 46);">1和0交替的序文。这是射频协议中非常常见的技术，用于通知传入信号并同步时钟频率</font></li><li><font style="color:rgb(42, 43, 46);">对于每个设备都是恒定的字节序列。例如，门传感器将始终发送相同的字节序列，摄像机将发送另一个字节序列，等等。这对应于一个同步字，它经常在射频协议中发现，用于确定协议类型或消息来自哪个设备。据推测，这是某种ID，用于告诉主面板该消息来自哪个外设。</font></li><li><font style="color:rgb(13, 13, 13);">一系列零位。据推测，这是同步字的一部分。这也是 RF 协议中常见的技术，用于让接收器知道这是什么协议，以及有效载荷数据从何处开始。</font></li><li><font style="color:rgb(42, 43, 46);">一串看似随机的比特，可能是有效载荷</font></li></ol><p><font style="color:rgb(147, 149, 153);"></font></p><p><strong>门防拆传感器开启</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000015d477e072b922530064</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a0000028648b07e291d2ceecc</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a0000280b9d2e1d2d2ca7f31c</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00002548c662f2feeea7fe22</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000019201db301398d538674</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00000806d6a5ee37481e2f76</font></li></ul><p><strong>门防拆传感器关闭</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a0000102366a5cb78d61c0d0c</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00000a3b2cb0867bf62aa616</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000028fe2271f089a9e8c984</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00001e23195bcbe8c65107ec</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00001913b1ee7e3448da1cf0</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000006f69dbb732deb2a120c</font></li></ul><p><strong>摄像头防拆传感器开启</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li></ul><p><strong>摄像头防拆传感器关闭</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li></ul><p><font style="color:rgb(13, 13, 13);">然而，payload 显然被加密或至少以某种方式混淆了。实际方法是什么，以及它是否是一个加密安全的方法，这些问题都没有答案。加密可能很弱。在没有固件或关于 RF 协议的其他文档的情况下进一步的逆向工程几乎是不可能的。</font></p><h3 id="sgsxl"><font style="color:rgb(13, 13, 13);">RF 干扰攻击</font></h3><font style="color:rgb(13, 13, 13);">无线电频谱是用于无线通信的介质。它本质上容易受到干扰攻击的影响。这可以类比于 RF 版本的 DoS 攻击。对 RF 通信进行干扰攻击涉及将电磁能量定向到一个或多个无线电频率，以干扰或阻止两个系统之间的信号传输。在实践中，这意味着在特定频率上发送信号，携带足够的能量来击败在相同频段传输的任何人。通过持续发送信号，使无线频段充满，可以阻止合法的流量。</font><p><font style="color:rgb(13, 13, 13);">由于 RF 通信使用共享介质，因此这是一种非常难以防范的攻击。通常，系统将在单一固定频率上进行通信，这可能使系统特别容易受到干扰攻击。尽管已经开发出许多复杂的技术来检测干扰，但检测和报告仅限于系统对干扰攻击的反应程度。通常情况下，除了可能切换频率带或切换到备用通信模式外，很少能做其他事情。</font></p><h4 id="DcPZp"><font style="color:rgb(13, 13, 13);">方法</font></h4><font style="color:rgb(13, 13, 13);">为了发送信号，使用了 HackRF SDR。它被放置在系统附近，距离在 10-20 厘米之间。使用了开源程序 GnuRadio Companion。这是一个图形工具，用于控制 SDR。它基于创建连接组件的流图，用于接收、处理、修改和发送来自和到 SDR 的实时无线电信号。</font><p><font style="color:rgb(13, 13, 13);">为了生成噪声信号，在 GnuRadio Companion 中创建了一个流图，如图所示。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011901996.png"></p><p><font style="color:rgb(13, 13, 13);">首先，使用快速噪声发生器作为源信号。然后将噪声输出链接到低通滤波器，以将信号集中到感兴趣的特定频率带。最后，将输出发送到 HackRF 通过 osmocom Sink 块。此外，低通滤波器的输出还发送到一个 QT GUI 频率接收器，以在执行攻击时可视化呈现发送信号数据。</font></p>]]></content>
    
    
    <summary type="html">这是一篇关于无线电分析经历的简要介绍。</summary>
    
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>无线电安全入门-以固定码为例展示如何分析无线电协议</title>
    <link href="https://ch0en3.github.io/2025/03/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8-%E4%BB%A5%E5%9B%BA%E5%AE%9A%E7%A0%81%E4%B8%BA%E4%BE%8B%E5%B1%95%E7%A4%BA%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%97%A0%E7%BA%BF%E7%94%B5%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ch0en3.github.io/2025/03/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8-%E4%BB%A5%E5%9B%BA%E5%AE%9A%E7%A0%81%E4%B8%BA%E4%BE%8B%E5%B1%95%E7%A4%BA%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%97%A0%E7%BA%BF%E7%94%B5%E5%8D%8F%E8%AE%AE/</id>
    <published>2025-03-15T16:57:41.395Z</published>
    <updated>2025-03-15T17:28:37.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pjf0P">一.前言</h1><p>这篇文章的由来来自于对一个固定码的无线信号进行分析时候发现的一个现象，并由此文记录下从发现问题到解决问题的完整过程。</p><p>为了更方便理解 以下是本文当中出现的所有设备</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010127668.jpeg"></p><p>它们依照从左到右的顺序为 RTL-SDR，RSP1，esp32，无线门铃</p><p>以下会以 sdr 来替代 rtl-sdr 和 rsp1.</p><p>文中所用软件：universal radio hacker,cc1101-tool</p><h1 id="fUNRT">二:问题由来</h1>本次分析的目标是收集目标设备发送的信号并且进行重放。由于在前言当中提到的 sdr 设备只有接收信号的功能而并不能发送信号，因此我采用了 esp32 搭配 cc1101 来完成信号的发送。为了实现这个目的，我需要将 sdr 接收到的调制信号转换为十六进制字符串并且输入到我的 esp32 设备当中。<p>第一步做的事情是收集信号并且分析。</p><p>以下的所有详细分析过程可以观看 b 站视频(<a href="https://www.bilibili.com/video/BV11YULYjEfy),%E8%BF%99%E9%87%8C%E4%B8%8D%E8%BF%87%E5%A4%9A%E8%B5%98%E8%BF%B0">https://www.bilibili.com/video/BV11YULYjEfy),这里不过多赘述</a></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010139766.png"></p><p>可以看到我们接收到的信号是这样的。</p><p>第二步我们要把数据转换为正确的形式，按照原理，转换后我们应该会得到这样的一些信号</p><p>80000000（这是由于前面还有一小段脉冲 但是由于过滤没有被显示 要加上）</p><p>8e88eeee88ec7477477747740000000</p><p>8e88eeee88ee8e8ee8eee8ee80000000</p><p>8e88eeee88ee8e8ee8eee8ee0000000</p><p>接着我们要把 urh 分析得到的序列号填写进我们的 esp 设备当中</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010147022.png"></p><p>可以看到这里共有十六个由小脉冲信号组成的大脉冲信号，我们只需要按照如图所示的顺序填入我们的 esp32 当中即可。</p><p>那么填完后 esp32 当中缓冲区内的数据应该是这样的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010150003.png"></p><p>此时我们能够正常激活目标设备</p><p>但是我们还有第二种方法也能够实现同样的目标，使用 esp32 自带的记录功能并且重放</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010152181.png"></p><p>可以看到我们成功的记录下了信号并且将其保存在缓冲区当中</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010154432.png"></p><p>并且也能够成功执行</p><p>于是问题产生了，我们可以很明显的发现缓冲区当中的数据和我们开始的数据并不一样。但为什么也能够正常执行？</p><p>使用 URH 进行观察，我们用 URH 捕获 esp32 重放的信号。发现它是这样子的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010156622.png"></p><p>那么通过观察我们可以发现 这三段信号都不一样。为什么都能够触发设备？</p><h1 id="zpJN9">三.研究过程</h1>分别分析三段信号，以下按照如上文章顺序我们分别命名为 原始信号，esp32 接收信号，esp 32 发出信号<pre><code class="language-plain">8e88eeee88ec7477477747748e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee</code></pre><pre><code class="language-plain">800000008E007777447FA3A3BA3BFD1DD000000010E88EEEE8C7747477C3BBA3BA000000011D11DDFE88EE8E8F747774774000000023A23DDDD11DD1F8EE8EEE8F74000000047403BBBA23FC1D1DD1DDE0EE8000000087447777447BA3A3BA3DDD1DD000000008E88EEEF847747477A3BBA3BA000000011D11DFEE88EE8F877477747FA000000023A21DDDD11DF0E8EE8EEE8774000000047823BBBA23DD1D1DD1FEE8EE80000000C7447777423BA3A3BE1DDD1DD000000008E88EFFF44774747BA3BBA3BC000000011D11EEEE88EE8FC77477747BA000000023801DDDD11FE8E8EE8FFF4774000000043A23BBBA01DD1D1DD0EEE8EE80000000474477FFA23BA3A3DD1DDD1DE  </code></pre><pre><code class="language-plain">8e8077774477c3a3ba3bbe1dd8f047777447ba3a3ba3fdd1dd8e88eeee047747477c3bba3ba8e88eeffa23ba3a3dd1ddd1df8e88f777447747a3ba3bba3dd8e807777447ff1d1dd1ddf8ee887447777447ba3a3ba3fdd1dd8e88eeef847747477c3bba3ba8e88eeff44774747ba3bba3ba8e88ff77447747c3ba3bba3fd8e887777447747a3ba3bbc7748eeeee88ff47477477fa3ba87447777443ba3a3ba3ddd1dd8e88eeef047747477e3bba3ba8e88eff744774747ba3bba3bf8e88f777447747a3ba3bba3fc</code></pre><p>来比较他们的异同，可以发现一些有趣的情况</p><ol start="2"><li><strong>共同部分与差异分析</strong></li></ol><ul><li><strong>共同特征</strong>：在所有三段信号中，都能找到一些类似的字节序列，例如 <code>8e88</code>, <code>eeee</code>, <code>7747</code>, 以及 <code>ba3b</code>。这些序列可能是信号中用来识别的关键特征。</li><li><strong>差异</strong>：在每一段信号中，存在大量的变化和不同之处，尤其是在中间部分。这些差异可能是由于信号存储设备的处理方式不同，或者是由于设备在不同时间接收到的信号有所不同。</li></ul><ol start="3"><li><strong>关键部分识别</strong></li></ol><ul><li><strong>核心部分可能性</strong>：<ul><li>在第一段信号中，<code>8e88eeee88ee8e8ee8eee8ee8</code> 这一部分反复出现，并且在最后一行 <code>8e88eeee877474774777477</code> 中的 <code>8e88eeee</code> 和 <code>7747</code> 出现频率较高，这表明这一部分可能是触发门铃的关键部分。</li><li>第二段信号中的 <code>8e88eeee047747477c3bba3ba</code> 和第三段信号中的 <code>8e88eeee8C7747477C3BBA3BA</code> 也都包含类似的 <code>8e88</code> 和 <code>7747</code>，这进一步表明这些序列可能是关键。</li></ul></li></ul><p>可以发现不管是哪一段信号当中都出现有 <code>8E88EEEF</code> 和 <code>84774747</code>，那么这是否意味着<code>8E88EEEF</code> 和 <code>84774747</code> 就是触发门铃信号的关键？</p><p>可以做个简单的实验。仿照esp32接收信号的格式，我们生成一段新的随机字符串</p><pre><code class="language-plain">800000008E88EFFF84774747C3BBA3BA000000011D11DFEE88EE8F877477747FA000000023A21DDDD11DF0E8EE8EEE8774000000047823BBBA23DD1D1DF8EE8EEE8F74000000047403BBBA23FC1D1DD1DDE0EE8000000087447777447BA3A3BA3DDD1DD000000008E8 8EEEF84774747C3BBA3BA000000011D11DFEE88EE8F877477747FA000000023A21DDDD11DF0E8EE8EEE8774000000047823BBBA23DD1D1DF8EE8EEE8F74000000047403BBBA23FC1D1DD1DDE0EE80000000C7447777423BA3A3BE1DDD1DD000000008E88EFFF84774747BA3BBA3BC000000011D11EEEE88EE8FC77477747BA000000023801DDDD11FE8E8EE8FFF4774000000043A23BBBA01DD1D1DD0EEE8EE80000000474477FFA23BA3A3DD1DDD1DE</code></pre><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010200841.png"></p><p>可以发现触发成功</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010202646.png"></p><h1 id="rv6jm">四.结论</h1>通过我们实验可以发现`8E88EEEF` 和 `84774747`就是触发设备的核心部分。那么为什么在不同的数据当中会有如此之多的不同数据出现？<p>这就涉及到了无线信号的冗余和容错机制。</p><p>由于在现实生活当中存在非常多的干扰不能够完全的确保发送的无线电信号能够正确的被接收端接收到，因此我们需要冗余和容错机制。</p><ul><li><strong>冗余编码</strong>：许多无线设备发送信号时都会加入大量冗余数据，以增强信号在噪声或干扰环境中的可靠性。这些冗余数据使得即使信号在某些部分发生了改变或丢失，接收设备仍然能够正确识别。</li><li><strong>容错能力</strong>：门铃的接收器可能有一定的容错能力，只要收到的信号大致匹配，就会触发门铃。因此，虽然两个信号在细节上有差异，但只要它们在某些关键特征上符合预期，就能成功触发门铃。</li><li><strong>信号帧结构</strong>：有些无线设备的信号由多个帧组成，每个帧包含控制信息、数据部分和校验信息。即使不同设备对这些帧的解析结果不同，只要接收器能够正确识别某些帧，就能触发动作。</li></ul><p>通过上述一系列实验，那么我们可以得到一个对无线电协议分析的一个结论。在研究无线电信号协议的时候一个目的就是找到无线电信号当中信号的一个有效的部分</p>]]></content>
    
    
    <summary type="html">以固定码为例展示如何分析无线电协议</summary>
    
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客&amp;闲谈</title>
    <link href="https://ch0en3.github.io/2025/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E9%97%B2%E8%B0%88/"/>
    <id>https://ch0en3.github.io/2025/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E9%97%B2%E8%B0%88/</id>
    <published>2025-03-15T16:39:47.824Z</published>
    <updated>2025-03-15T16:51:49.170Z</updated>
    
    <content type="html"><![CDATA[<p>写博客的想法一早就有了因为懒所以鸽了很久（主要语雀比较方便<br>转移一些语雀上的文章和随笔,也算是在互联网上留下个人痕迹了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写博客的想法一早就有了因为懒所以鸽了很久（主要语雀比较方便&lt;br&gt;转移一些语雀上的文章和随笔,也算是在互联网上留下个人痕迹了&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://ch0en3.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
