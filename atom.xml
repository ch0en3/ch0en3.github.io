<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ch0en3&#39;s blog</title>
  
  <subtitle>当时年少春衫薄</subtitle>
  <link href="https://ch0en3.github.io/atom.xml" rel="self"/>
  
  <link href="https://ch0en3.github.io/"/>
  <updated>2025-03-16T03:12:57.558Z</updated>
  <id>https://ch0en3.github.io/</id>
  
  <author>
    <name>ch0en3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nrfbox-蓝牙黑客硬件设备制作</title>
    <link href="https://ch0en3.github.io/2025/03/%E8%93%9D%E7%89%99%E9%BB%91%E5%AE%A2%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E5%88%B6%E4%BD%9C/"/>
    <id>https://ch0en3.github.io/2025/03/%E8%93%9D%E7%89%99%E9%BB%91%E5%AE%A2%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E5%88%B6%E4%BD%9C/</id>
    <published>2025-03-15T18:27:00.000Z</published>
    <updated>2025-03-16T03:12:57.558Z</updated>
    
    <content type="html"><![CDATA[<p>该工具出自<a href="https://cifertech.net/nrfbox-your-all-in-one-gadget-for-ble-and-2-4ghz-networks/">https://cifertech.net/nrfbox-your-all-in-one-gadget-for-ble-and-2-4ghz-networks/</a></p><p>个人对这款工具做了一些小小的改进，增加了中继部分的功能。代码就不放了如果有感兴趣的师傅想要复现的可以私下交流</p><p>制作难度应该主要出现在硬件制作层面，这边分享一下我买的器件表。他提供的 bom 表在嘉立创很难找到合适的 需要自己去配</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110707854.jpeg"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110723825.jpeg" alt="1729504368429-c2f6e72c-c27b-457b-a3d0-4c6ea69c7adb"><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110834237.jpeg" alt="1729504369895-88554f1e-663d-4077-aaf3-8c7dbf8a4db3"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110844708.jpeg" alt="1729504371237-1be0c917-3731-4a34-b2d0-39b72e16c18e"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316111207852.jpeg"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316111212249.jpeg"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316111216233.jpeg"></p><p> <img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110907069.jpeg"></p><p>然后就是焊接的问题</p><p>主要多注意芯片和显示屏的引脚，因为引脚比较密所以很容易短路</p><p>一些成品照片</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316014221734.jpg" alt="36516482af4a94d6535d46997aafd19"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316014227301.jpg" alt="0af1b8325780dcbfeb562ed4f2c62ae"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316014230952.jpg" alt="f2f6989be1e77e4ef384f664891fbce"></p>]]></content>
    
    
    <summary type="html">这是一篇关于蓝牙黑客硬件设备制作简要介绍。
</summary>
    
    
    
    <category term="bluetooth" scheme="https://ch0en3.github.io/categories/bluetooth/"/>
    
    <category term="hardware" scheme="https://ch0en3.github.io/categories/bluetooth/hardware/"/>
    
    
    <category term="bluetooth" scheme="https://ch0en3.github.io/tags/bluetooth/"/>
    
    <category term="hardware" scheme="https://ch0en3.github.io/tags/hardware/"/>
    
  </entry>
  
  <entry>
    <title>车联网安全之滚动码系统研究</title>
    <link href="https://ch0en3.github.io/2025/03/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E4%B9%8B%E6%BB%9A%E5%8A%A8%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6/"/>
    <id>https://ch0en3.github.io/2025/03/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E4%B9%8B%E6%BB%9A%E5%8A%A8%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6/</id>
    <published>2025-03-15T16:58:33.619Z</published>
    <updated>2025-03-16T03:13:34.646Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发自先知社区<a href="https://xz.aliyun.com/news/17201">https://xz.aliyun.com/news/17201</a></p><h1 id="k9oqU">一.研究背景</h1><h2 id="vvkce">浅析汽车钥匙系统</h2><h3 id="zLSvU">前言</h3><p><font style="color:rgb(43, 56, 53);">从无线遥控无钥匙进入 (RKE) 系统开始，到功能更强大的被动式进入系统 (PEK)和被动进入&#x2F;被动启动(PEPS)，再到被动式安全进入系统 (PASE)。无钥匙进入系统在过去 40 年里得到了迅猛发展。</font><font style="color:rgb(43, 43, 43);">它从一种技术跳到另一种技术，从简单的 ASK、FSK 调制到蓝牙低功耗（BLE）系统中的编码跳频扩频，再到超宽带（UWB）调制。同样，在安全领域，从简单的无编码数字技术到编码数字技术、滚动编码和高级加密标准（AES）的实施，使这项技术达到了更高的安全水平。</font></p><h3 id="6fff77c9"><font style="color:rgb(43, 56, 53);">遥控钥匙（RKE，Remote Keyless Entry）</font></h3>**工作原理**<font style="color:rgb(43, 56, 53);">：</font><ol><li><strong>发送信号</strong><font style="color:rgb(43, 56, 53);">：当用户按下遥控钥匙上的按钮时，遥控器会发送一个无线电频率（RF）信号。这个信号包含了特定的识别码，用于与车辆进行匹配。</font></li><li><strong>接收信号</strong><font style="color:rgb(43, 56, 53);">：车辆上的接收器接收到这个RF信号，并解析其中的识别码。</font></li><li><strong>验证信号</strong><font style="color:rgb(43, 56, 53);">：如果识别码与车辆预先存储的识别码匹配，接收器会发送信号到车载控制单元（ECU）。</font></li><li><strong>执行指令</strong><font style="color:rgb(43, 56, 53);">：ECU执行相应的动作，比如解锁车门、锁定车门或打开行李箱。</font></li></ol><p><strong>技术</strong><font style="color:rgb(43, 56, 53);">：</font></p><ul><li><font style="color:rgb(43, 56, 53);">使用RF信号，一般工作在315 MHz或433 MHz频段。</font></li><li><font style="color:rgb(43, 56, 53);">采用滚动码技术防止信号被拦截和复制</font></li></ul><p><font style="color:rgb(43, 43, 43);">作为 PEPS 的前身，RKE 通过钥匙扣向与汽车 BCM（车身控制模块）相连的射频接收器发射 UHF（超高频）信号，以验证用户身份。一旦身份得到验证，系统将执行由 BCM 驱动的开门&#x2F;关门动作。如图所示，这种单向验证机制可以验证预设密码。如果密码正确，他或她就会被允许进入。</font></p><p><font style="color:rgb(43, 43, 43);"></font></p><h3 id="fd1c6730"><font style="color:rgb(43, 56, 53);">被动进入系统（PKE，Passive Keyless  Entry）</font></h3>**工作原理**<font style="color:rgb(43, 56, 53);">：</font><ol><li><strong>信号发送</strong><font style="color:rgb(43, 56, 53);">：车辆会周期性地发送低频（LF）信号，这个信号的范围一般在1-3米以内。</font></li><li><strong>钥匙响应</strong><font style="color:rgb(43, 56, 53);">：当携带钥匙的用户进入这个范围时，钥匙会接收到车辆的LF信号并响应，发送一个高频（HF）信号回给车辆。</font></li><li><strong>验证信号</strong><font style="color:rgb(43, 56, 53);">：车辆接收到钥匙的HF信号，并解析其中的识别码。</font></li><li><strong>执行指令</strong><font style="color:rgb(43, 56, 53);">：如果识别码匹配，车辆会自动解锁车门。</font></li></ol><p><strong>技术</strong><font style="color:rgb(43, 56, 53);">：</font></p><ul><li><font style="color:rgb(43, 56, 53);">使用LF信号进行近距离通信（125 kHz）。</font></li><li><font style="color:rgb(43, 56, 53);">HF信号用于远距离通信（通常是RF信号，315 MHz或433 MHz）。</font></li><li><font style="color:rgb(43, 56, 53);">使用双向认证和加密技术提高安全性。</font></li></ul><p><font style="color:rgb(43, 43, 43);">到 21 世纪初，人们将 RKE 的单向验证机制升级为称为 PKE（被动式无钥匙进入）系统的双向机制，验证不再由钥匙持有者（即驾驶员）启动，而是由车上连接到 BCM 的低频发射器启动。车门关闭并上锁后，车内的无线模块将持续发射低频（125KHz）信号，寻找一定范围内的应答器（内置在钥匙扣中）。当模块找到应答器时，其代码将唤醒应答器。如果模块的低频部分长时间没有收到反馈信号，它就会进入睡眠模式，以降低功耗。每当钥匙扣中的应答器接收到唤醒信号时，它就会通过高频（即 433MHz）信号发送滚动编码数据报。内置模块解码并理解数据报后，将指示汽车执行某些操作。由此可见，与 RKE 相比，PKE 采用的验证机制是双向的。</font></p><h3 id="edfd47be"><font style="color:rgb(43, 56, 53);">被动进入和启动系统（PEPS，Passive Entry Passive Start）</font></h3>**工作原理**<font style="color:rgb(43, 56, 53);">：</font><ol><li><strong>进入车辆</strong><font style="color:rgb(43, 56, 53);">：</font><ul><li><font style="color:rgb(43, 56, 53);">工作原理与PKE 相同，车辆会发送LF信号，钥匙响应并发送HF信号，车辆验证并解锁车门。</font></li></ul></li><li><strong>启动车辆</strong><font style="color:rgb(43, 56, 53);">：</font><ul><li><font style="color:rgb(43, 56, 53);">当用户进入车内并按下启动按钮时，车辆会再次发送LF信号以确认钥匙是否在车内。</font></li><li><font style="color:rgb(43, 56, 53);">钥匙响应并发送HF信号，车辆验证识别码。</font></li><li><font style="color:rgb(43, 56, 53);">如果识别码匹配，车辆的ECU允许启动引擎。</font></li></ul></li></ol><p><strong>技术</strong><font style="color:rgb(43, 56, 53);">：</font></p><ul><li><font style="color:rgb(43, 56, 53);">结合PEK的所有技术。</font></li><li><font style="color:rgb(43, 56, 53);">通过车辆内的多个天线阵列实现更精确的钥匙定位，确保钥匙在车内时才能启动引擎。</font></li></ul><p><font style="color:rgb(43, 43, 43);">PEPS 是一种安全的无线通信系统，可使驾驶员在不使用钥匙的情况下进入汽车，解锁汽车并启动发动机。该系统使用射频信号，通过在汽车和钥匙之间发送信号来验证钥匙。PEPS 系统使用低频无线电波（通常为 125 千赫或 134 千赫）和超高频（UHF）无线电波（通常为 1 千兆赫以下的信号）进行双向通信，在钥匙和汽车之间交换唯一的钥匙访问代码。一旦交换的代码符合预期值，且钥匙在汽车附近，汽车就会允许驾驶员进入。系统还会测量汽车与钥匙之间的距离，以确定钥匙是在车内还是车外。这一信息可用于为驾驶员提供不同类型的访问权限。例如，如果钥匙在车外，则只允许进入车内，但发动机启动功能将不起作用。基本上，目前主流的 PEPS 都已集成了 NFC 和蓝牙功能。驾驶员可将 NFC 手机放在汽车 B 柱附近，然后进入车内。这消除了将钥匙扣和智能手机都放进口袋的麻烦。但将蓝牙引入 PEPS 则更具革命性。蓝牙的高频率、跳频机制和强化的安全机制与 UHF&#x2F;LF 的保证机制相比，提供了更多的安全保证。此外，蓝牙的测距和定位功能对掌握开关门的时机大有帮助。蓝牙测距和定位的精度可达半米或一米。它包括 RSSI 方法和 AoA 方法。前者精度较低，可达到 1 至 5 米的精度水平。后者精度更高，精度可达半米。</font></p><h3 id="8fcda306"></h3><h1 id="bRzv6">二.滚动码机制</h1>虽然汽车无钥匙进入系统已经发展了很多年，但是采用 RKE 依然大量存在。并且，由于滚动码机制的特殊性。在现如今依然存在大量使用滚动码的地方。因此，研究滚动码机制依然是非常有价值和意义的。<p>应用滚动码技术意味着每一个键的fob信号传输都是唯一的，即它随着每按一个按钮而变化。唯一性是通过在钥匙中心（以及在接收时的车辆中）增加一个16位宽计数器来实现的。如果两边的计数器都同步，则按下按钮有效。然后，每个方增加其计数器以同步按下以下按钮。因此，如果攻击者捕获了从钥匙中心发送的有效信号，并由车辆用计数器Ck &#x3D; n接收并重放它，它将被车辆中的接收器丢弃，作为其计数器Cv &gt; Ck，即Cv&#x3D;（n+&#x3D;）：k&gt;0。</p><p>另一方面，当钥匙扣超出车辆范围时，需要按下按钮，即使用钥匙扣来锁定&#x2F;解锁汽车和Ck &gt; Cv。这些情况被进一步分为两个不同的操作窗口</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010253895.webp">        </p><h3 id="2c60edda">单一窗口</h3>**单一窗口**是指计数器差值 _<font style="color:rgb(0,0,0);">Cdif f </font>_<font style="color:rgb(0,0,0);">= </font>_<font style="color:rgb(0,0,0);">Ck − Cv</font>_ 较小的情况。具体来说，当差值小于16时（即 _<font style="color:rgb(0,0,0);">Cdif f < </font>_<font style="color:rgb(0,0,0);">16</font>），系统可以在第一次按键按下时立即进行同步。这意味着当车辆接收到钥匙扣的信号后，它会立即更新自己的计数器，与钥匙扣的计数器保持一致，不需要额外的步骤。<p><strong>主要特点：</strong></p><ul><li><strong>同步快速</strong>：只需一次按键操作。</li><li><strong>差值较小</strong>：差值在16以内，车辆可以轻松同步。</li><li><strong>即时更新</strong>：车辆会立即更新其计数器，丢弃在这之前所有未接收到的代码。</li></ul><h3 id="8ede463a">重新同步/双窗口</h3>**重新同步/双窗口**是指计数器差值较大的情况。具体来说，当差值在<font style="color:rgb(0,0,0);">16 </font>_<font style="color:rgb(0,0,0);">< Cdif f < </font>_<font style="color:rgb(0,0,0);">2 15</font>时，系统需要进行重新同步。<p><strong>主要特点：</strong></p><ul><li><strong>同步需要两次按键操作</strong>：当车辆接收到一次信号时，暂时存储这个信号并等待下一次信号。如果下一次信号的计数器值比上次大1，则系统进行同步。</li><li><strong>差值较大</strong>：差值在16到<font style="color:rgb(0,0,0);">2 15</font>之间，车辆需要额外的验证步骤来确保安全。</li><li><strong>双步验证</strong>：车辆需要接收到两次连续的信号才能完成同步，从而提高了安全性，防止信号被重放攻击。</li></ul><p>如果上述任何一个失败，则车辆接收到的钥匙焦点信号被丢弃。此外，请注意，由于底层的加密机制即使是一位信息的变化（例如，计数器增量）也会导致最终传输信号的显著变化。因此，攻击者通过捕获上一个信号来推断下一个有效的解锁信号，这在计算上是不可行的。</p><p>请注意，当钥匙 fob 已经发出信号时，已发送的代码也可以被认为未使用，但车辆没有收到它。例如，当解锁按钮被意外按下时。（由图1a中的“解锁代码n+2”和“n+3”描述）。**为了避免不同步，从而在这种情况下将我们自己锁在我们的车辆之外，基于滚动代码的系统提供了一个安全功能，允许钥匙fob的计数器比车辆的计数器领先一步。**这是通过在车辆上维护的不是一组，而是一组有效的“未来代码”来实现的 。如果从钥匙fob接收到的代码与这些未来的代码匹配，车辆将重新同步到最后一个钥匙fob信号中的代码，并使该集合中所有以前（但未使用的）代码失效（参见图中的“解锁代码n+4”）。<strong>显然，如果攻击者可以获得这些未使用的未来代码之一（即，捕获汽车附近的意外按钮按下的信号），并且她可以在车主再次使用钥匙fob之前重播它，攻击者可以访问车辆</strong>。然而，在实践中获取这些未来的代码是极其困难的，特别是当攻击者想要瞄准一个随机的受害者时。这就是为什么这种安全配置被认为是一个方便的特性，使关键的fob使用无缝和更少的麻烦</p><h1 id="tpDwp">三.rollback 与 rolljam 工作机制探讨</h1>虽然理论上滚动码机制是一项安全的技术。但是在 2015 年一种名为 rolljam 的技术证明了基于滚动码的密钥系统是极易破坏的。简而言之，根据 rolljam 的原理破解滚动码系统只需要三个步骤：干扰，捕捉，重放.<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010257869.webp"></p><p>如上图 rolljam 部分的流程图所示，它分为四个步骤</p><ol><li>时刻捕捉信号</li><li>采用特定设备干扰车辆与钥匙的正常通信</li><li>因为干扰，从而引诱车主第二次发送解锁信号</li><li>重放先前捕获的第一次信号</li></ol><p>回顾一下这整个过程是怎么实现的。首先我们拥有一个可以实现干扰，捕捉，重放的设备。在攻击模型当中，受害者由于步骤三会按下两次解锁按钮。同时我们会得到两个滚动码，此时我们再重放第一次接收到的滚动码就可以攻击成功。为什么这个滚动码是有效的？还记得在上面的滚动码原理吗。由于滚动码是一次性的且必须按顺序使用，拦截并阻止一个滚动码后，合法用户的遥控器会发送下一个滚动码。这导致接收设备并没有意识到有一个滚动码已经被阻塞并存储下来。钥匙发送的信号并没有被车辆所接收到，这在滚动码设计当中是被允许的。因此，这个接收到的滚动码被判定为有效。攻击成功。</p><p>但是这样的作法存在很大的缺点：</p><ol><li>首先在这个攻击模型当中阻塞的作用非常关键。倘若阻塞装置不能很好的阻塞合法信息的通信，我们所收集到的滚动码会因此作废。这就导致了对阻塞装置的放置有很高的要求</li><li>与条件一类似。必须在收集信号完成后及时的使用它。否则它会随着滚动的信号更新而失效，整个攻击流程必须从头开始</li></ol><p>针对 rolljam 的以上缺点另外一种名为 rollback 的机制被提出。顾名思义它叫做回滚，利用的便是滚动码当中的回滚机制。在不同的 RKE 系统当中回滚系统都不同。但是存在回滚机制的系统原理都是当<strong>多个已经连续被发送过的滚动码被重新发送</strong>，这个时候滚动码系统认为自身出现了错误，从而回滚到之前的已经被使用过的滚动码。这个过程如上图中右图所示。与 rolljam 的工作步骤类似：</p><ol><li>时刻捕捉信号</li><li>采用特定设备干扰车辆与钥匙的正常通信</li><li>因为干扰，从而引诱车主第二次发送解锁信号</li></ol><p>然而我们并不需要第四个步骤，因为回滚机制的存在。我们可以在任意时间重放这个滚动码,这个滚动码都有效。</p><h1 id="X0O1Z">四.基于 esp32 的 rollback 与 rolljam 攻击原理的 CTF 题目</h1><h4 id="a0PWI">硬件部分</h4>esp32+cc1101 x2<p>一个 SDR(RTL-SDR 即可</p><p>rolljam 和 rollback 设备，这里使用的是自制的 EvilcrowRF</p><h4 id="rnHpL">软件部分</h4>[https://github.com/ch0en3/rollback-rolljam_ctf]<p>感兴趣的师傅可以玩一下</p>]]></content>
    
    
    <summary type="html">滚动码系统研究
</summary>
    
    
    
    <category term="car-hacking" scheme="https://ch0en3.github.io/categories/car-hacking/"/>
    
    
    <category term="car-hacking" scheme="https://ch0en3.github.io/tags/car-hacking/"/>
    
  </entry>
  
  <entry>
    <title>一次无线电分析经历</title>
    <link href="https://ch0en3.github.io/2025/03/%E4%B8%80%E6%AC%A1%E6%97%A0%E7%BA%BF%E7%94%B5%E5%88%86%E6%9E%90%E7%BB%8F%E5%8E%86/"/>
    <id>https://ch0en3.github.io/2025/03/%E4%B8%80%E6%AC%A1%E6%97%A0%E7%BA%BF%E7%94%B5%E5%88%86%E6%9E%90%E7%BB%8F%E5%8E%86/</id>
    <published>2025-03-15T16:58:09.515Z</published>
    <updated>2025-03-15T17:28:21.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nL9lG">利用URH的步骤</h3><ol><li>记录信号</li><li>信号说明</li><li>信号分析</li></ol><p>首先找到通过URH自带的频谱分析器寻找到系统通信的中心频率。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011842426.png"></p><p>找到中心频率后利用记录信号工具捕获信号。urh可以记录从sdr中捕获的原始音频信号。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011844967.png"></p><p><font style="color:rgb(13, 13, 13);">过放大捕获的音频信号并观察清晰的正弦波形以及非平凡的模式，可以验证捕获很可能是正确的</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011847379.png"></p><p>一旦信号被捕获到就可以利用URH的发送信号工具进行重播</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011849682.png"></p><h2 id="w1KdN">逆向工程RF协议</h2><font style="color:rgb(13, 13, 13);">所讨论的系统使用 RF 信号在设备之间进行无线通信。这些无线电波用于在每个设备之间传输二进制数据，即 0 和 1。通过无线电波传输二进制数据的过程称为调制 。</font><p><font style="color:rgb(13, 13, 13);">有三种主要的简单调制二进制信号的方式：幅度键控 (ASK)、频率键控 (FSK) 和相位键控 (PSK)。它们分别产生不同的波形，可以很容易地通过视觉识别。如图所示。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011852263.png"></p><p><font style="color:rgb(13, 13, 13);">每种技术都使用正弦波的不同属性来分别编码零和一。幅度键控 (ASK) 使用波的振幅，其中较高的振幅通常编码为 1，较低的振幅编码为 0。频率键控 (FSK) 则保持振幅和相位不变。而是在两个不同的频率之间进行切换以区分 0 和 1。最后，相位键控 (PSK) 使用相位变化来区分这两个符号。</font></p><p><font style="color:rgb(13, 13, 13);">解调是将调制信号转换回原始二进制数据的过程。在 RF 通信的大多数实际应用中，这是直接在硬件中完成的，使用专门的无线电接收器和电路自动将信号转换回二进制数据 。通常，该硬件还实现了错误校正、噪声过滤和其他技术，以增加通信的可靠性，因为干扰和其他干扰在现实世界中是不可避免的。</font></p><p><font style="color:rgb(13, 13, 13);"></font></p><p><font style="color:rgb(13, 13, 13);">urh可以自动解调，但是很多时候无法找到正确的调制参数。因此我们可以使用audacity进行手动解调。</font></p><p><font style="color:rgb(13, 13, 13);">解调的步骤如下：</font></p><ol><li><font style="color:rgb(13, 13, 13);">将 URH 捕获的原始信号数据通过菜单选项文件 - 导入 - 原始数据导入到 Audacity 中。URH 将信号保存为有符号 8 位字节的原始 IQ 数据。通过选择编码为有符号 8 位 PCM 的 2 通道 (立体声)，可以将数据的 I 和 Q 组件分开并导入到两个单独的轨道中。在这种情况下，仅使用其中一个足以提取信息。因此，在 Audacity 中，将立体声轨道拆分为两个单声道轨道，然后删除第二个轨道。导入选项的其余部分并不重要。</font></li><li><font style="color:rgb(13, 13, 13);">其次，记录 Audacity 感知到的中心频率。可以通过菜单选项分析 - 绘制频谱来找到这一点。注意，由于样本率等多个特征不是原始信号数据的一部分，因此此频率可能不等于实际的 868.64 MHz 的中心频率。在下面的步骤中使用了这个频率。</font></li><li><font style="color:rgb(13, 13, 13);">对第一个轨道应用高通滤波器，并对第二个轨道应用低通滤波器，将滚降值设置为 48 dB。前者基本上将较高的频率映射到输出波中的较高振幅，后者则相反。</font></li><li><font style="color:rgb(13, 13, 13);">使用 Audacity 的脚本语言 Nyquist 对每个轨道应用绝对值。使用了简短的 Nyquist 程序 (s-abs </font><em><font style="color:rgb(13, 13, 13);">track</font></em><font style="color:rgb(13, 13, 13);">) 来实现。然后对两个轨道应用了低通滤波器，计算了信号的包络。最后，对最初应用了低通滤波器的轨道进行了反转。这意味着现在两个轨道分别对应于原始信号的高频和低频部分。</font></li><li><font style="color:rgb(13, 13, 13);">接下来，将两个轨道混合到一起形成一个新轨道，即将信号相加。</font></li><li><font style="color:rgb(13, 13, 13);">将混合轨道放大到尽可能高的程度，并启用剪切，以创建一个二进制信号。这创建了最终信号，即从原始信号解调出的原始二进制信号。</font></li><li><font style="color:rgb(13, 13, 13);">最后，将最终的二进制波形导出为原始数据到文件中。通过选择最终轨道并使用菜单选项文件 - 导出 - 导出所选音频 来完成。在随后的文件对话框中，选择”其他未压缩文件”作为类型，并选择无标题 (例如 RAW)，并选择有符号 8 位 PCM 编码。这样就可以将信号导出为原始二进制振幅数据，表示为有符号字节。</font></li></ol><p><font style="color:rgb(13, 13, 13);"></font></p><p><font style="color:rgb(13, 13, 13);">这就是解调信号的过程</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011854887.png"></p><p>经过此过程的结果是一个二进制波形而不是一段实际的二进制数据,因此编写了一个简单的python程序用于提取</p><pre><code class="language-c">import matplotlib.pyplot as pltSIGNAL_LEN, SYMBOL_LEN = 34000, 200FILE, SIGNAL_OFFSETS = &quot;door-signal.raw&quot;, [1800, 856160, ...]with open(FILE, &quot;rb&quot;) as f:signal = [b if b &lt; 128 else b - 256 for b in f.read()]for i, offset in enumerate(SIGNAL_OFFSETS):xs = range(offset, offset + SIGNAL_LEN, SYMBOL_LEN)plt.scatter(xs, [0 for _ in xs], c=&quot;red&quot;)bits = &quot;&quot;.join([&#39;1&#39; if signal[x] &gt; 0 else &#39;0&#39; for x in xs])print(f&quot;Packet &#123;str(i).ljust(2)&#125; =&quot;, hex(int(bits, 2)))plt.plot(signal)plt.show()</code></pre><p><font style="color:rgb(13, 13, 13);">该程序期望一个 x 轴偏移值列表，其中包含信号的第一个比特位。这些值是手动找到的，通过手动查看程序创建的图来实现。信号长度和符号长度也是手动测量的，但这些对于所有捕获的信号来说是恒定的。只需手动推导出每个信号的信号起始偏移量，这相当耗时。因此，这个过程仅应用于少数信号，直到收集到足够的信息来对协议做出结论。</font></p><p><font style="color:rgb(13, 13, 13);"></font></p><p><font style="color:rgb(13, 13, 13);">通过使用 Audacity 和描述的方法，从每个记录的信号中提取了二进制数据。这些数据以十六进制形式呈现在表中。分析数据后可以看到一个非常清晰的结构。所有记录的信号解码后都恰好为 170 位，并且始终具有以下结构。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011858946.png"></p><ol><li><font style="color:rgb(42, 43, 46);">1和0交替的序文。这是射频协议中非常常见的技术，用于通知传入信号并同步时钟频率</font></li><li><font style="color:rgb(42, 43, 46);">对于每个设备都是恒定的字节序列。例如，门传感器将始终发送相同的字节序列，摄像机将发送另一个字节序列，等等。这对应于一个同步字，它经常在射频协议中发现，用于确定协议类型或消息来自哪个设备。据推测，这是某种ID，用于告诉主面板该消息来自哪个外设。</font></li><li><font style="color:rgb(13, 13, 13);">一系列零位。据推测，这是同步字的一部分。这也是 RF 协议中常见的技术，用于让接收器知道这是什么协议，以及有效载荷数据从何处开始。</font></li><li><font style="color:rgb(42, 43, 46);">一串看似随机的比特，可能是有效载荷</font></li></ol><p><font style="color:rgb(147, 149, 153);"></font></p><p><strong>门防拆传感器开启</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000015d477e072b922530064</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a0000028648b07e291d2ceecc</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a0000280b9d2e1d2d2ca7f31c</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00002548c662f2feeea7fe22</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000019201db301398d538674</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00000806d6a5ee37481e2f76</font></li></ul><p><strong>门防拆传感器关闭</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a0000102366a5cb78d61c0d0c</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00000a3b2cb0867bf62aa616</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000028fe2271f089a9e8c984</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00001e23195bcbe8c65107ec</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00001913b1ee7e3448da1cf0</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000006f69dbb732deb2a120c</font></li></ul><p><strong>摄像头防拆传感器开启</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li></ul><p><strong>摄像头防拆传感器关闭</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li></ul><p><font style="color:rgb(13, 13, 13);">然而，payload 显然被加密或至少以某种方式混淆了。实际方法是什么，以及它是否是一个加密安全的方法，这些问题都没有答案。加密可能很弱。在没有固件或关于 RF 协议的其他文档的情况下进一步的逆向工程几乎是不可能的。</font></p><h3 id="sgsxl"><font style="color:rgb(13, 13, 13);">RF 干扰攻击</font></h3><font style="color:rgb(13, 13, 13);">无线电频谱是用于无线通信的介质。它本质上容易受到干扰攻击的影响。这可以类比于 RF 版本的 DoS 攻击。对 RF 通信进行干扰攻击涉及将电磁能量定向到一个或多个无线电频率，以干扰或阻止两个系统之间的信号传输。在实践中，这意味着在特定频率上发送信号，携带足够的能量来击败在相同频段传输的任何人。通过持续发送信号，使无线频段充满，可以阻止合法的流量。</font><p><font style="color:rgb(13, 13, 13);">由于 RF 通信使用共享介质，因此这是一种非常难以防范的攻击。通常，系统将在单一固定频率上进行通信，这可能使系统特别容易受到干扰攻击。尽管已经开发出许多复杂的技术来检测干扰，但检测和报告仅限于系统对干扰攻击的反应程度。通常情况下，除了可能切换频率带或切换到备用通信模式外，很少能做其他事情。</font></p><h4 id="DcPZp"><font style="color:rgb(13, 13, 13);">方法</font></h4><font style="color:rgb(13, 13, 13);">为了发送信号，使用了 HackRF SDR。它被放置在系统附近，距离在 10-20 厘米之间。使用了开源程序 GnuRadio Companion。这是一个图形工具，用于控制 SDR。它基于创建连接组件的流图，用于接收、处理、修改和发送来自和到 SDR 的实时无线电信号。</font><p><font style="color:rgb(13, 13, 13);">为了生成噪声信号，在 GnuRadio Companion 中创建了一个流图，如图所示。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011901996.png"></p><p><font style="color:rgb(13, 13, 13);">首先，使用快速噪声发生器作为源信号。然后将噪声输出链接到低通滤波器，以将信号集中到感兴趣的特定频率带。最后，将输出发送到 HackRF 通过 osmocom Sink 块。此外，低通滤波器的输出还发送到一个 QT GUI 频率接收器，以在执行攻击时可视化呈现发送信号数据。</font></p>]]></content>
    
    
    <summary type="html">这是一篇关于无线电分析经历的简要介绍。</summary>
    
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>无线电安全入门-以固定码为例展示如何分析无线电协议</title>
    <link href="https://ch0en3.github.io/2025/03/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8-%E4%BB%A5%E5%9B%BA%E5%AE%9A%E7%A0%81%E4%B8%BA%E4%BE%8B%E5%B1%95%E7%A4%BA%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%97%A0%E7%BA%BF%E7%94%B5%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ch0en3.github.io/2025/03/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8-%E4%BB%A5%E5%9B%BA%E5%AE%9A%E7%A0%81%E4%B8%BA%E4%BE%8B%E5%B1%95%E7%A4%BA%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%97%A0%E7%BA%BF%E7%94%B5%E5%8D%8F%E8%AE%AE/</id>
    <published>2025-03-15T16:57:41.395Z</published>
    <updated>2025-03-15T17:28:37.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pjf0P">一.前言</h1><p>这篇文章的由来来自于对一个固定码的无线信号进行分析时候发现的一个现象，并由此文记录下从发现问题到解决问题的完整过程。</p><p>为了更方便理解 以下是本文当中出现的所有设备</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010127668.jpeg"></p><p>它们依照从左到右的顺序为 RTL-SDR，RSP1，esp32，无线门铃</p><p>以下会以 sdr 来替代 rtl-sdr 和 rsp1.</p><p>文中所用软件：universal radio hacker,cc1101-tool</p><h1 id="fUNRT">二:问题由来</h1>本次分析的目标是收集目标设备发送的信号并且进行重放。由于在前言当中提到的 sdr 设备只有接收信号的功能而并不能发送信号，因此我采用了 esp32 搭配 cc1101 来完成信号的发送。为了实现这个目的，我需要将 sdr 接收到的调制信号转换为十六进制字符串并且输入到我的 esp32 设备当中。<p>第一步做的事情是收集信号并且分析。</p><p>以下的所有详细分析过程可以观看 b 站视频(<a href="https://www.bilibili.com/video/BV11YULYjEfy),%E8%BF%99%E9%87%8C%E4%B8%8D%E8%BF%87%E5%A4%9A%E8%B5%98%E8%BF%B0">https://www.bilibili.com/video/BV11YULYjEfy),这里不过多赘述</a></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010139766.png"></p><p>可以看到我们接收到的信号是这样的。</p><p>第二步我们要把数据转换为正确的形式，按照原理，转换后我们应该会得到这样的一些信号</p><p>80000000（这是由于前面还有一小段脉冲 但是由于过滤没有被显示 要加上）</p><p>8e88eeee88ec7477477747740000000</p><p>8e88eeee88ee8e8ee8eee8ee80000000</p><p>8e88eeee88ee8e8ee8eee8ee0000000</p><p>接着我们要把 urh 分析得到的序列号填写进我们的 esp 设备当中</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010147022.png"></p><p>可以看到这里共有十六个由小脉冲信号组成的大脉冲信号，我们只需要按照如图所示的顺序填入我们的 esp32 当中即可。</p><p>那么填完后 esp32 当中缓冲区内的数据应该是这样的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010150003.png"></p><p>此时我们能够正常激活目标设备</p><p>但是我们还有第二种方法也能够实现同样的目标，使用 esp32 自带的记录功能并且重放</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010152181.png"></p><p>可以看到我们成功的记录下了信号并且将其保存在缓冲区当中</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010154432.png"></p><p>并且也能够成功执行</p><p>于是问题产生了，我们可以很明显的发现缓冲区当中的数据和我们开始的数据并不一样。但为什么也能够正常执行？</p><p>使用 URH 进行观察，我们用 URH 捕获 esp32 重放的信号。发现它是这样子的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010156622.png"></p><p>那么通过观察我们可以发现 这三段信号都不一样。为什么都能够触发设备？</p><h1 id="zpJN9">三.研究过程</h1>分别分析三段信号，以下按照如上文章顺序我们分别命名为 原始信号，esp32 接收信号，esp 32 发出信号<pre><code class="language-plain">8e88eeee88ec7477477747748e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee</code></pre><pre><code class="language-plain">800000008E007777447FA3A3BA3BFD1DD000000010E88EEEE8C7747477C3BBA3BA000000011D11DDFE88EE8E8F747774774000000023A23DDDD11DD1F8EE8EEE8F74000000047403BBBA23FC1D1DD1DDE0EE8000000087447777447BA3A3BA3DDD1DD000000008E88EEEF847747477A3BBA3BA000000011D11DFEE88EE8F877477747FA000000023A21DDDD11DF0E8EE8EEE8774000000047823BBBA23DD1D1DD1FEE8EE80000000C7447777423BA3A3BE1DDD1DD000000008E88EFFF44774747BA3BBA3BC000000011D11EEEE88EE8FC77477747BA000000023801DDDD11FE8E8EE8FFF4774000000043A23BBBA01DD1D1DD0EEE8EE80000000474477FFA23BA3A3DD1DDD1DE  </code></pre><pre><code class="language-plain">8e8077774477c3a3ba3bbe1dd8f047777447ba3a3ba3fdd1dd8e88eeee047747477c3bba3ba8e88eeffa23ba3a3dd1ddd1df8e88f777447747a3ba3bba3dd8e807777447ff1d1dd1ddf8ee887447777447ba3a3ba3fdd1dd8e88eeef847747477c3bba3ba8e88eeff44774747ba3bba3ba8e88ff77447747c3ba3bba3fd8e887777447747a3ba3bbc7748eeeee88ff47477477fa3ba87447777443ba3a3ba3ddd1dd8e88eeef047747477e3bba3ba8e88eff744774747ba3bba3bf8e88f777447747a3ba3bba3fc</code></pre><p>来比较他们的异同，可以发现一些有趣的情况</p><ol start="2"><li><strong>共同部分与差异分析</strong></li></ol><ul><li><strong>共同特征</strong>：在所有三段信号中，都能找到一些类似的字节序列，例如 <code>8e88</code>, <code>eeee</code>, <code>7747</code>, 以及 <code>ba3b</code>。这些序列可能是信号中用来识别的关键特征。</li><li><strong>差异</strong>：在每一段信号中，存在大量的变化和不同之处，尤其是在中间部分。这些差异可能是由于信号存储设备的处理方式不同，或者是由于设备在不同时间接收到的信号有所不同。</li></ul><ol start="3"><li><strong>关键部分识别</strong></li></ol><ul><li><strong>核心部分可能性</strong>：<ul><li>在第一段信号中，<code>8e88eeee88ee8e8ee8eee8ee8</code> 这一部分反复出现，并且在最后一行 <code>8e88eeee877474774777477</code> 中的 <code>8e88eeee</code> 和 <code>7747</code> 出现频率较高，这表明这一部分可能是触发门铃的关键部分。</li><li>第二段信号中的 <code>8e88eeee047747477c3bba3ba</code> 和第三段信号中的 <code>8e88eeee8C7747477C3BBA3BA</code> 也都包含类似的 <code>8e88</code> 和 <code>7747</code>，这进一步表明这些序列可能是关键。</li></ul></li></ul><p>可以发现不管是哪一段信号当中都出现有 <code>8E88EEEF</code> 和 <code>84774747</code>，那么这是否意味着<code>8E88EEEF</code> 和 <code>84774747</code> 就是触发门铃信号的关键？</p><p>可以做个简单的实验。仿照esp32接收信号的格式，我们生成一段新的随机字符串</p><pre><code class="language-plain">800000008E88EFFF84774747C3BBA3BA000000011D11DFEE88EE8F877477747FA000000023A21DDDD11DF0E8EE8EEE8774000000047823BBBA23DD1D1DF8EE8EEE8F74000000047403BBBA23FC1D1DD1DDE0EE8000000087447777447BA3A3BA3DDD1DD000000008E8 8EEEF84774747C3BBA3BA000000011D11DFEE88EE8F877477747FA000000023A21DDDD11DF0E8EE8EEE8774000000047823BBBA23DD1D1DF8EE8EEE8F74000000047403BBBA23FC1D1DD1DDE0EE80000000C7447777423BA3A3BE1DDD1DD000000008E88EFFF84774747BA3BBA3BC000000011D11EEEE88EE8FC77477747BA000000023801DDDD11FE8E8EE8FFF4774000000043A23BBBA01DD1D1DD0EEE8EE80000000474477FFA23BA3A3DD1DDD1DE</code></pre><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010200841.png"></p><p>可以发现触发成功</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010202646.png"></p><h1 id="rv6jm">四.结论</h1>通过我们实验可以发现`8E88EEEF` 和 `84774747`就是触发设备的核心部分。那么为什么在不同的数据当中会有如此之多的不同数据出现？<p>这就涉及到了无线信号的冗余和容错机制。</p><p>由于在现实生活当中存在非常多的干扰不能够完全的确保发送的无线电信号能够正确的被接收端接收到，因此我们需要冗余和容错机制。</p><ul><li><strong>冗余编码</strong>：许多无线设备发送信号时都会加入大量冗余数据，以增强信号在噪声或干扰环境中的可靠性。这些冗余数据使得即使信号在某些部分发生了改变或丢失，接收设备仍然能够正确识别。</li><li><strong>容错能力</strong>：门铃的接收器可能有一定的容错能力，只要收到的信号大致匹配，就会触发门铃。因此，虽然两个信号在细节上有差异，但只要它们在某些关键特征上符合预期，就能成功触发门铃。</li><li><strong>信号帧结构</strong>：有些无线设备的信号由多个帧组成，每个帧包含控制信息、数据部分和校验信息。即使不同设备对这些帧的解析结果不同，只要接收器能够正确识别某些帧，就能触发动作。</li></ul><p>通过上述一系列实验，那么我们可以得到一个对无线电协议分析的一个结论。在研究无线电信号协议的时候一个目的就是找到无线电信号当中信号的一个有效的部分</p>]]></content>
    
    
    <summary type="html">以固定码为例展示如何分析无线电协议</summary>
    
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客&amp;闲谈</title>
    <link href="https://ch0en3.github.io/2025/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E9%97%B2%E8%B0%88/"/>
    <id>https://ch0en3.github.io/2025/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E9%97%B2%E8%B0%88/</id>
    <published>2025-03-15T16:39:47.824Z</published>
    <updated>2025-03-15T16:51:49.170Z</updated>
    
    <content type="html"><![CDATA[<p>写博客的想法一早就有了因为懒所以鸽了很久（主要语雀比较方便<br>转移一些语雀上的文章和随笔,也算是在互联网上留下个人痕迹了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写博客的想法一早就有了因为懒所以鸽了很久（主要语雀比较方便&lt;br&gt;转移一些语雀上的文章和随笔,也算是在互联网上留下个人痕迹了&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://ch0en3.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
