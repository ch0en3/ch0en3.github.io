<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ch0en3&#39;s blog</title>
  
  <subtitle>当时年少春衫薄</subtitle>
  <link href="https://ch0en3.github.io/atom.xml" rel="self"/>
  
  <link href="https://ch0en3.github.io/"/>
  <updated>2025-03-16T04:53:52.246Z</updated>
  <id>https://ch0en3.github.io/</id>
  
  <author>
    <name>ch0en3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>硬件黑客-Pwnagotchi</title>
    <link href="https://ch0en3.github.io/2025/03/%E7%A1%AC%E4%BB%B6%E9%BB%91%E5%AE%A2-Pwnagotchi/"/>
    <id>https://ch0en3.github.io/2025/03/%E7%A1%AC%E4%BB%B6%E9%BB%91%E5%AE%A2-Pwnagotchi/</id>
    <published>2025-03-16T04:49:07.784Z</published>
    <updated>2025-03-16T04:53:52.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="beN5t">介绍</h1><p>Pwnagotchi是一个基于a2c的“ai”，由bettercap提供支持，它从周围的WiFi环境中学习，以最大限度地获取可破解的WPA密钥材料(通过被动嗅测或执行去认证和关联攻击)。这些资料以PCAP文件的形式收集在磁盘上，包含hashcat支持的任何形式的可破解握手，包括完整的和一半的WPA握手以及PMKIDs。</p><p>简单点说的话它就是一个可以帮助你捕获破解wifi所需要握手包的工具（其实重点在它像个电子宠物一样</p><h2 id="dGmid">工作原理</h2>只需要知道它可以进行深度学习就行，但是有一点不一样的地方是。它与通常的强化学习模拟不同，Pwnagotchi实际上是在人类的时间尺度上学习的，因为它是与现实世界的环境互动，而不是一个定义良好的虚拟环境(比如玩超级马里奥)。一幅画的时间是用年代来衡量的;一个epoch可以持续几秒到几分钟，这取决于有多少接入点和客户端站可见。<p>不要期望你的Pwnagotchi在一开始就表现得非常好，因为它将探索几个关键参数的组合，以确定在开始阶段对特定环境的理想调整。但当你的Pwnagotchi告诉你它很无聊的时候，一定要听!把它带到新的WiFi环境中，让它观察新的网络，捕捉新的握手——你会看到的。：）</p><p>随着时间的推移，两个或更多的Pwnagotchi单位一起训练，将学会合作，通过分配可用的频道来探测彼此的存在。（有点类似于边缘计算</p><h2 id="YKAWo">攻击原理</h2>在连接到无线接入点的客户端设备(例如，连接到家庭WiFi网络的手机)能够安全地传输和接收来自该接入点的数据之前，需要进行一个称为4次握手的过程，以便生成WPA加密密钥。这个过程包括在客户端设备和AP之间交换四个数据包;它们用于从接入点的WiFi密码中获得会话密钥。一旦成功交换了数据包并生成了密钥，客户端设备就可以通过身份验证，并开始向无线AP发送和接收数据包(现在通过加密保护)。<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125053971.png"></p><p>问题出在四次握手的过程中，这四个握手包很容易被嗅探。一旦记录下来就可以使用字典或者暴力破解握手包并恢复原始wifi密钥。而在实战中我们甚至不需要全部4个握手包，只有一半即两个也可以以破解。在大多数情况下即使没有连接一个握手包就足够了。</p><h1 id="BdRNZ">硬件要求</h1>1. 一个树莓派zero w2. 至少8gb以上的内存的SD卡3. 移动电源供电（可以用充电宝也可以买专门为树莓派zero设计的ups-lite4. 一块水墨屏 waveshare 2.135. 一条结实可靠的micro usb数据线<p>均可以在淘宝上购买</p><h3 id="nQLy9">如何安装</h3>[https://pwnagotchi.ai/installation/#flashing-an-image](https://pwnagotchi.ai/installation/#flashing-an-image)<p>最方便的方式就是使用官方提供的镜像，使用<a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a>进行写入</p><p>安装步骤如下</p><ol><li>下载镜像文件</li><li>下载 balenaetcher并且安装</li><li>连接好读卡器</li><li>打开balenaetcher选择树莓派镜像</li><li>写入卡中</li></ol><details class="lake-collapse"><summary id="uf207c31d"><span class="ne-text">这里记录一下踩坑的一些点</span></summary><p id="udc0ca7be" class="ne-p"><span class="ne-text">在淘宝上买屏幕我们买的是v3版本的，在官方镜像中不兼容。所以建议下载1.56 beta版本的镜像</span></p><p id="ua0de47c1" class="ne-p"><a href="https://github.com/DrSchottky/pwnagotchi/releases" data-href="https://github.com/DrSchottky/pwnagotchi/releases" target="_blank" class="ne-link"><span class="ne-text">https://github.com/DrSchottky/pwnagotchi/releases</span></a></p><p id="u95221cc7" class="ne-p"><span class="ne-text"></span></p><p id="u5eba149c" class="ne-p"><span class="ne-text">关于如何安装带有v3屏幕的pwnagochi这里是教程</span></p><p id="u879b6f08" class="ne-p"><a href="https://pwnsec.io/how-to-make-a-pwnagotchi-in-2022-with-a-waveshare-v3-screen/" data-href="https://pwnsec.io/how-to-make-a-pwnagotchi-in-2022-with-a-waveshare-v3-screen/" target="_blank" class="ne-link"><span class="ne-text">https://pwnsec.io/how-to-make-a-pwnagotchi-in-2022-with-a-waveshare-v3-screen/</span></a></p><p id="u09082f7f" class="ne-p"><br></p><p id="u5f59b89a" class="ne-p"><span class="ne-text">省流版本的话就是在安装1.56版本的镜像后把config.toml的内容更改为</span></p><p id="ud17ff7bc" class="ne-p"><span class="ne-text">main.name = “NameOfYourPwnagotchi”<br /></span><span class="ne-text">main.lang = “en”<br /></span><span class="ne-text">main.whitelist = [<br /></span><span class="ne-text">“YourWifiYouDontWantToSniff”<br /></span><span class="ne-text">]</span></p><p id="uebcbe049" class="ne-p"><span class="ne-text">main.plugins.grid.enabled = false<br /></span><span class="ne-text">main.plugins.grid.report = false<br /></span><span class="ne-text">main.plugins.grid.exclude = [<br /></span><span class="ne-text">“YourHomeNetworkHere”<br /></span><span class="ne-text">]</span></p><p id="ud23ee860" class="ne-p"><span class="ne-text">ui.display.enabled = true<br /></span><span class="ne-text">ui.display.type = “waveshare_3”<br /></span><span class="ne-text">ui.display.color = “black”</span></p><p id="u86745c63" class="ne-p"><span class="ne-text">personality.advertise = false<br /></span><span class="ne-text">personality.deauth = false</span></p></details><p>以上是装在树莓派zero w中的。这是linux版本教程</p><p><a href="https://pwnagotchi.ai/installation/#installing-on-any-gnu-linux">https://pwnagotchi.ai/installation/#installing-on-any-gnu-linux</a></p><h3 id="H6kAV">安装完后的配置</h3>在安装好镜像后需要做的第一件事情是进行配置。通过读卡器在SD卡boot目录下面新建一个config.toml文件。然后输入以下内容<pre><code class="language-python">main.name = &quot;pwnagotchi&quot;main.lang = &quot;en&quot;main.whitelist = [  &quot;EXAMPLE_NETWORK&quot;,  &quot;ANOTHER_EXAMPLE_NETWORK&quot;,  &quot;fo:od:ba:be:fo:od&quot;,  &quot;fo:od:ba&quot;]main.plugins.grid.enabled = truemain.plugins.grid.report = truemain.plugins.grid.exclude = [  &quot;YourHomeNetworkHere&quot;]ui.display.enabled = trueui.display.type = &quot;waveshare213d&quot;ui.display.color = &quot;black&quot;</code></pre><p>接着把micro usb线连接上电脑</p><p>注意！这里很有可能出现连接电脑后识别不出的情况，这是因为在正常情况下windows系统会把rndis识别成串口，我们需要做的是打上驱动</p><p><a href="https://blog.csdn.net/baidu_32237719/article/details/78189144">https://blog.csdn.net/baidu_32237719&#x2F;article&#x2F;details&#x2F;78189144</a></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125103412.png"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125101186.png"></p><p>安装成功</p><h1 id="kSWXR">如何使用</h1><h2 id="FGFtx">模式介绍</h2>**MANU模式**<p>在连接到设备usb数据接口的情况下它将以手动模式启动，它能够读取一些日志文件并在屏幕上统计数据。这是当想要从单位传输数据时候应该使用的模式</p><p><strong>AUTO模式</strong></p><p>如果在只连接usb电源端口的情况下这是设备默认启动的模式。例如只有连接段源码却没有连接到电脑数据端口上时。自动模式下单位将自动开始操作执行攻击</p><p><strong>AI模式</strong></p><p>如果你在默认配置中启动了ai模式，auto模式将在几分钟后转换为ai（它的转换时间取决于sd卡的读取速度）。这段时间被用于加载ai模块所使用的所有依赖并且初始化神经网络。一旦依赖被加载，即&#x2F;root&#x2F;brain.nn文件会被唤醒，ai模式将自动选择最佳的参数集。这取决于它训练了多长时间</p><h2 id="pwHAj">ui</h2>如果通过usb0连接到设备并在网络接口上设置了静态地址。在默认情况下它的地址是[http://pwnagotchi.local:8080/](http://pwnagotchi.local:8080/)<p>它的默认用户名和密码都是changeme，如果你想要把它更改为自己的名字可以在config.toml中更改</p><h3 id="WZDpd">墨水屏配置和详细解读</h3>![](https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125110613.png)<ul><li><strong>CH</strong>:这显示的是当前运行的channel，当在所有通道上执行嗅探和跳频时候它将显示*而不是一个具体的数字。它在嗅探的时候会收集每个频道上的ap数量。</li><li><strong>AP</strong>:显示的是当前信道上的接入点数量，括号中显示了所有通道的可见访问点总数（根据最后一次嗅探的信道</li><li><strong>UP</strong>:设备的正常运行时间，自上次重新启动以来。格式为hh:mm:ss。</li><li><strong>PWND</strong>:在当前会话中捕获的握手次数。括号中显示的是pwnagochi从安装开始至少握手过唯一ssid的数量，花括号中显示的是pwnagochi最近一次进行握手的ssid</li><li><strong>MODE</strong>:表示pwnagochi当前以什么模式进行运行<ul><li><strong>MANU</strong></li><li>这种模式适合更新和备份你的单位和使用bettercap的web UI。</li><li>Pwnagotchi在手动模式下不会嗅或捕捉握手。</li><li>陷入手动模式?打开未连接USB网线的设备。</li><li><strong>AUTO</strong></li><li>在这种模式下Pwnagotchi仍然会嗅探并捕获握手;它主要是功能性的——自动模式和人工智能模式之间的主要区别是，它的行动是由静态算法决定的，而不是由人工智能决定Pwnagotchi应该做什么来获得最佳pwnage。</li><li>一旦AI依赖项被引导并且神经网络完成加载，这就消失了。(按RPi0W计算，这个过程大约需要20-30分钟。)</li><li>如果你在没有启用AI的情况下运行Pwnagotchi，这是你将保持的模式。</li><li><strong>AI</strong></li><li>一旦出现了这样标识就表明pizerow准备好开始训练了</li></ul></li></ul><p>成品展示</p><p><img src="C:/Users/Administrator/Documents/Tencent%20Files/893413848/FileRecv/MobileFile/Image_7140246746598.jpg" alt="Image_7140246746598"></p>]]></content>
    
    
    <summary type="html">这是一篇关于Pwnagotchi简要介绍。
</summary>
    
    
    
    <category term="wifi" scheme="https://ch0en3.github.io/categories/wifi/"/>
    
    
    <category term="hardware" scheme="https://ch0en3.github.io/tags/hardware/"/>
    
    <category term="wifi" scheme="https://ch0en3.github.io/tags/wifi/"/>
    
  </entry>
  
  <entry>
    <title>门禁控制系统(PACS)与OSDP攻击研究</title>
    <link href="https://ch0en3.github.io/2025/03/%E9%97%A8%E7%A6%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EOSDP%E6%94%BB%E5%87%BB%E7%A0%94%E7%A9%B6/"/>
    <id>https://ch0en3.github.io/2025/03/%E9%97%A8%E7%A6%81%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%B8%8EOSDP%E6%94%BB%E5%87%BB%E7%A0%94%E7%A9%B6/</id>
    <published>2025-03-16T04:32:22.517Z</published>
    <updated>2025-03-16T04:58:33.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uMEsn">门禁控制系统原理</h1>一个标准的门禁控制系统由几部分组成。门，锁，rfid 读卡器。<p>一个正常的流程如图所示</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125708385.png"></p><p>一个带有门禁卡权限的人把门禁卡放在读卡器上，读卡器就会正确的读卡并开门。但是这个过程中要注意的是，读卡器并不会对你的卡进行鉴权，它只能够读取卡片并且将卡片的内容发送到位于后端的控制器并由控制器进行判断。如果控制器接收到的信息是正确的，控制器再发送开门的命令给锁并且发送一个信号给读卡器使得读卡器亮正确的灯</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125712042.png"></p><p>然而在读卡器传输信息到控制器这个过程当中是完全没有加密的。这是因为一种名为韦根（wiegand）协议。因此我们很容易就能够实现中间人攻击去获取正确的权限。有一个名为 espkey(<a href="https://github.com/octosavvi/ESPKey">https://github.com/octosavvi/ESPKey</a>) 的设备可以很轻松的完成这一点</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125715174.png"></p><h1 id="LP8KS">OSDP 背景介绍</h1>因此在以上的基础之上，OSDP 被提出用于替代韦根协议。OSDP 对读卡器到控制器这一过程进行了加密并且采用了强加密算法。保证传输过程无法被解密![](https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125718325.png)<p>在 OSDP 中为了防止简单的重放攻击，它对协议包的加密是这样的：在正确的数据后面会加上一个序列号以确保每一条信息都一致。接着他们被打包为 hmac</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125720984.png"></p><p>因此直接破解加密信息是完全不现实的。</p><p>在此基础之上 OSDP 还使用了 AES-CBC 模式来加密通信数据 </p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125723451.png"></p><p>在上述 OSDP 的背景之下.HMAC 有一个非常不好的一点就是它实际上只有前 32 个字节是被维护的，后面 96 个字节实际上是可被丢弃的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125725863.png"></p><p>这一功能在规范当中是被这么描述的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125727984.png"></p><p>甚至为了减少传输时间，只发送 4 个字节。</p><p>这就意味着，我们可以使用生日攻击去破解这 32 位字节</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125730507.png"></p><p>这个过程中不涉及到任何新的数据，我们只是在一遍又一遍的重复播放上述收集到的信息.</p><p>容易出现漏洞的地方</p><p>协议，库，配置</p><h1 id="KzWPx">针对 OSDP 的攻击方式</h1>针对 OSDP 有一个名为 mellon 的工具[https://github.com/BishopFox/mellon](https://github.com/BishopFox/mellon)<h2 id="sc8bS">攻击方式 一 加密不强制</h2>osdp 支持加密并不强制性要求加密。osdp 支持一个安全通道但是这个并不是强制性要求的而是一个可选项![](https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125733475.png)<p>此外由于 OSDP 基于 RS485 协议运行，这是一个串行协议。因此如果有多个控制器，他们在系统当中应该是这样的。不同的阅读器同时存在同一根总线上与控制器相连接，所有的信息都通过总线传播</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125736754.png"></p><p>因此这就意味着，假设我想要打开的目标门禁为 A。我只需要把一个监听设备放在其它的读卡器位置就能收到门禁 A 的信息。</p><p>在 OSDP 系统当中，所有的读卡器都是客户端，只有控制器是服务端。所有的信息都是由控制器发送，而读卡器只能够回复</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125739013.png"></p><h2 id="p6l1r">攻击方式 2 降级攻击</h2>当读卡器启动的时候，控制器和读卡器之间会有一个握手，控制器会像读卡器发出一个质询去询问读卡器的能力<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125741122.png"></p><p>接着读卡器就会返回一些基础信息给控制器。例如是否有生物指纹信息，有键盘数据等等..在这堆数据里面有一个很有趣的东西叫做通信安全位。所以我们可以在这中间加入 mellon。当读卡器启动的时候，它向控制器返回一些信息, 将这个通信安全位从 1 被篡改为 0 了。控制器就会自然而然的认为读卡器不支持加密，这样 降级攻击就完成了<img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125743387.png"></p><h2 id="hD3pZ">攻击方式 3 安装模式  </h2><font style="color:rgb(55, 65, 81);">OSDP 有一个准官方的 “安装模式”，适用于读卡器和控制器。顾名思义，它应该在首次设置读取器时使用。它的作用本质上是允许读者向控制器询问基本加密密钥 （SCBK） 是什么。</font><p><font style="color:rgb(55, 65, 81);">这本身并不是一个疯狂的想法。它基于 SSH：第一次的配置是不安全的，在配置完成后就会安全   。问题是，许多控制器被配置为永久保持 “安装模式” ，也许是永远保持 “安装模式”。一些控制器在完成后会让管理员手动单击退出 “install mode”。</font></p><p><font style="color:rgb(55, 65, 81);">当读卡器和控制器都处于安装模式，就像 SSH 的配对模式一样。读卡器会像控制器发出质询获取密钥</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125745765.png"></p><p>接着控制器会把加密的密钥返回给读卡器。问题是，如果安装模式没有退出的话。攻击者便可以重复这个流程，获取到 ssh 密钥</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125747680.png"></p><h2 id="zqP3I">攻击方式 4 弱键</h2>在数据包加密当中我们希望看到的数据结构应该是这样的<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125749854.png"></p><p>由头 明文 和数据构成。但这是被加密后的结果，而不是一截命令  </p><p>但这是实际上我们看到的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125751987.png"></p><p>实际上 command byte 会告诉我们信息是如何传输的。</p><p>例如 OSDP_RAW，OSDP_fmt,OSDP keyset 的信息</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125755994.png"></p><p>基本上，消息的密钥包含正在被传递的加密密钥。</p><p>为什么这会是一个安全问题？ 实际上这个问题与 OSDP 协议本身无关</p><p>在实现一个通信协议的时候它们实际会引用到很多很多的库。</p><p>这是加密密钥的层次结构。控制器中存储有一个或曾经有一个主密钥。会话密钥由该主密钥派生，然后进行实际加密.osdp的新标准摆脱了主密钥，因此只有会话基础密钥和加密密钥。</p><p> <img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125758299.png">     协议设置了这些但是实际上并没有说明我们应该如何导出会话基本密钥。我们可以在网络上找到很多 osdp 引用库的硬编码密钥。这些库正在使用这些密钥来进行基础的加密</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125800310.png"></p><p>假设我们通过设备从总线上获取了一些加密的密钥</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125802350.png"></p><p>现在我们可以尝试使用了一大堆无意义的升序数字或者降序数字，总共 1 千个密钥。如果真的猜出一个 那么这时候我们就可以解密了。</p><h2 id="imwXc">攻击方式 5 密钥集捕获</h2>这个过程只使用了 AES，问题是如果只使用对称加密而在这个过程中没有非对称算法对密钥加密该如何进行密钥交换？  <p>在这里使用的是一个名为 SCBK-D 的东西。</p><p>:::info<br><strong>SCBK-D</strong> 是 OSDP（Open Supervised Device Protocol）中的<strong>默认安全会话密钥（Secure Channel Base Key - Default）</strong>。在OSDP协议中，安全通信是通过一个安全通道来实现的，而这个通道的密钥就是<strong>SCBK</strong>（Secure Channel Base Key）。</p><h3 id="wQKpn">SCBK-D 的具体作用</h3>1. **安全通道**：在OSDP协议中，为了保护敏感数据（如认证信息或命令），设备之间可以建立一个加密的安全通道。这个通道依赖于一个基础密钥，称为SCBK。2. **SCBK-D 是默认密钥**：    - **SCBK-D（Secure Channel Base Key - Default）** 是在设备没有被安全配置的情况下使用的默认密钥。    - 当使用默认密钥时，设备之间的通信并没有得到良好的保护，因为SCBK-D是一个标准的、已知的密钥，任何人都可以在公开文档中找到它。因此，设备默认的安全性较低，容易受到中间人攻击或其他形式的攻击。3. **安全建议**：出于安全考虑，生产环境中应避免使用SCBK-D。在部署系统时，应该使用特定的、安全配置的SCBK（非默认），通过配对双方的密钥来确保通信的机密性和完整性。<h3 id="J0COq">SCBK vs SCBK-D 的区别</h3>+ **SCBK（自定义密钥）**：    - SCBK是为每个设备自定义的密钥，用来建立安全通道，通常在设备初始化时进行配置。它提供了高等级的安全性。    - 这些自定义密钥可以通过安全方式配置，确保只有合法的控制面板和外围设备之间能够通信。+ **SCBK-D（默认密钥）**：    - SCBK-D是标准化的密钥，适用于设备出厂时的初始配置，用于测试或调试。使用默认密钥时，通信并不安全，容易被攻击。<p>:::</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125806046.png"></p><p>那么这里的 SCBK-D 其实就是我们上面提到的硬编码</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316125808074.png"></p><p>那么作为一个攻击者如何才能够获取这个基本密钥？遗憾的是由于 OSDP 没有外带机制，因此我们如果想要获取这个基本密钥只能够是让控制器发送这个密钥才能获取它。</p><p>所以在实际的物理红队攻击当中我们可以设想这样的攻击场景</p><ol><li>损坏 RFID 读卡器。这有很多种办法，例如我们可以使用某些 NFC 工具使得 RFID 读卡器收到损害无法正常工作，或者直接暴力拆开。总之这一目的是使得读卡器无法正常工作</li><li>在 RS485 总线上放一个监听设备</li><li>等待读卡器被更换</li><li>通过网络获取 keyset 信息</li></ol>]]></content>
    
    
    <summary type="html">门禁控制系统(PACS)与OSDP攻击研究
</summary>
    
    
    
    <category term="rfid" scheme="https://ch0en3.github.io/categories/rfid/"/>
    
    
    <category term="rfid" scheme="https://ch0en3.github.io/tags/rfid/"/>
    
  </entry>
  
  <entry>
    <title>硬件黑客-Nrfbox</title>
    <link href="https://ch0en3.github.io/2025/03/%E7%A1%AC%E4%BB%B6%E9%BB%91%E5%AE%A2-nrfbox/"/>
    <id>https://ch0en3.github.io/2025/03/%E7%A1%AC%E4%BB%B6%E9%BB%91%E5%AE%A2-nrfbox/</id>
    <published>2025-03-15T18:27:00.000Z</published>
    <updated>2025-03-16T04:50:00.668Z</updated>
    
    <content type="html"><![CDATA[<p>该工具出自<a href="https://cifertech.net/nrfbox-your-all-in-one-gadget-for-ble-and-2-4ghz-networks/">https://cifertech.net/nrfbox-your-all-in-one-gadget-for-ble-and-2-4ghz-networks/</a></p><p>个人对这款工具做了一些小小的改进，增加了中继部分的功能。代码就不放了如果有感兴趣的师傅想要复现的可以私下交流</p><p>制作难度应该主要出现在硬件制作层面，这边分享一下我买的器件表。他提供的 bom 表在嘉立创很难找到合适的 需要自己去配</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110707854.jpeg"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110723825.jpeg" alt="1729504368429-c2f6e72c-c27b-457b-a3d0-4c6ea69c7adb"><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110834237.jpeg" alt="1729504369895-88554f1e-663d-4077-aaf3-8c7dbf8a4db3"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110844708.jpeg" alt="1729504371237-1be0c917-3731-4a34-b2d0-39b72e16c18e"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316111207852.jpeg"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316111212249.jpeg"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316111216233.jpeg"></p><p> <img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316110907069.jpeg"></p><p>然后就是焊接的问题</p><p>主要多注意芯片和显示屏的引脚，因为引脚比较密所以很容易短路</p><p>一些成品照片</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316014221734.jpg" alt="36516482af4a94d6535d46997aafd19"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316014227301.jpg" alt="0af1b8325780dcbfeb562ed4f2c62ae"></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316014230952.jpg" alt="f2f6989be1e77e4ef384f664891fbce"></p>]]></content>
    
    
    <summary type="html">这是一篇关于nrfbox简要介绍。
</summary>
    
    
    
    <category term="bluetooth" scheme="https://ch0en3.github.io/categories/bluetooth/"/>
    
    <category term="hardware" scheme="https://ch0en3.github.io/categories/bluetooth/hardware/"/>
    
    
    <category term="bluetooth" scheme="https://ch0en3.github.io/tags/bluetooth/"/>
    
    <category term="hardware" scheme="https://ch0en3.github.io/tags/hardware/"/>
    
  </entry>
  
  <entry>
    <title>车联网安全之滚动码系统研究</title>
    <link href="https://ch0en3.github.io/2025/03/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E4%B9%8B%E6%BB%9A%E5%8A%A8%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6/"/>
    <id>https://ch0en3.github.io/2025/03/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E4%B9%8B%E6%BB%9A%E5%8A%A8%E7%A0%81%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6/</id>
    <published>2025-03-15T16:58:33.619Z</published>
    <updated>2025-03-16T03:13:34.646Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发自先知社区<a href="https://xz.aliyun.com/news/17201">https://xz.aliyun.com/news/17201</a></p><h1 id="k9oqU">一.研究背景</h1><h2 id="vvkce">浅析汽车钥匙系统</h2><h3 id="zLSvU">前言</h3><p><font style="color:rgb(43, 56, 53);">从无线遥控无钥匙进入 (RKE) 系统开始，到功能更强大的被动式进入系统 (PEK)和被动进入&#x2F;被动启动(PEPS)，再到被动式安全进入系统 (PASE)。无钥匙进入系统在过去 40 年里得到了迅猛发展。</font><font style="color:rgb(43, 43, 43);">它从一种技术跳到另一种技术，从简单的 ASK、FSK 调制到蓝牙低功耗（BLE）系统中的编码跳频扩频，再到超宽带（UWB）调制。同样，在安全领域，从简单的无编码数字技术到编码数字技术、滚动编码和高级加密标准（AES）的实施，使这项技术达到了更高的安全水平。</font></p><h3 id="6fff77c9"><font style="color:rgb(43, 56, 53);">遥控钥匙（RKE，Remote Keyless Entry）</font></h3>**工作原理**<font style="color:rgb(43, 56, 53);">：</font><ol><li><strong>发送信号</strong><font style="color:rgb(43, 56, 53);">：当用户按下遥控钥匙上的按钮时，遥控器会发送一个无线电频率（RF）信号。这个信号包含了特定的识别码，用于与车辆进行匹配。</font></li><li><strong>接收信号</strong><font style="color:rgb(43, 56, 53);">：车辆上的接收器接收到这个RF信号，并解析其中的识别码。</font></li><li><strong>验证信号</strong><font style="color:rgb(43, 56, 53);">：如果识别码与车辆预先存储的识别码匹配，接收器会发送信号到车载控制单元（ECU）。</font></li><li><strong>执行指令</strong><font style="color:rgb(43, 56, 53);">：ECU执行相应的动作，比如解锁车门、锁定车门或打开行李箱。</font></li></ol><p><strong>技术</strong><font style="color:rgb(43, 56, 53);">：</font></p><ul><li><font style="color:rgb(43, 56, 53);">使用RF信号，一般工作在315 MHz或433 MHz频段。</font></li><li><font style="color:rgb(43, 56, 53);">采用滚动码技术防止信号被拦截和复制</font></li></ul><p><font style="color:rgb(43, 43, 43);">作为 PEPS 的前身，RKE 通过钥匙扣向与汽车 BCM（车身控制模块）相连的射频接收器发射 UHF（超高频）信号，以验证用户身份。一旦身份得到验证，系统将执行由 BCM 驱动的开门&#x2F;关门动作。如图所示，这种单向验证机制可以验证预设密码。如果密码正确，他或她就会被允许进入。</font></p><p><font style="color:rgb(43, 43, 43);"></font></p><h3 id="fd1c6730"><font style="color:rgb(43, 56, 53);">被动进入系统（PKE，Passive Keyless  Entry）</font></h3>**工作原理**<font style="color:rgb(43, 56, 53);">：</font><ol><li><strong>信号发送</strong><font style="color:rgb(43, 56, 53);">：车辆会周期性地发送低频（LF）信号，这个信号的范围一般在1-3米以内。</font></li><li><strong>钥匙响应</strong><font style="color:rgb(43, 56, 53);">：当携带钥匙的用户进入这个范围时，钥匙会接收到车辆的LF信号并响应，发送一个高频（HF）信号回给车辆。</font></li><li><strong>验证信号</strong><font style="color:rgb(43, 56, 53);">：车辆接收到钥匙的HF信号，并解析其中的识别码。</font></li><li><strong>执行指令</strong><font style="color:rgb(43, 56, 53);">：如果识别码匹配，车辆会自动解锁车门。</font></li></ol><p><strong>技术</strong><font style="color:rgb(43, 56, 53);">：</font></p><ul><li><font style="color:rgb(43, 56, 53);">使用LF信号进行近距离通信（125 kHz）。</font></li><li><font style="color:rgb(43, 56, 53);">HF信号用于远距离通信（通常是RF信号，315 MHz或433 MHz）。</font></li><li><font style="color:rgb(43, 56, 53);">使用双向认证和加密技术提高安全性。</font></li></ul><p><font style="color:rgb(43, 43, 43);">到 21 世纪初，人们将 RKE 的单向验证机制升级为称为 PKE（被动式无钥匙进入）系统的双向机制，验证不再由钥匙持有者（即驾驶员）启动，而是由车上连接到 BCM 的低频发射器启动。车门关闭并上锁后，车内的无线模块将持续发射低频（125KHz）信号，寻找一定范围内的应答器（内置在钥匙扣中）。当模块找到应答器时，其代码将唤醒应答器。如果模块的低频部分长时间没有收到反馈信号，它就会进入睡眠模式，以降低功耗。每当钥匙扣中的应答器接收到唤醒信号时，它就会通过高频（即 433MHz）信号发送滚动编码数据报。内置模块解码并理解数据报后，将指示汽车执行某些操作。由此可见，与 RKE 相比，PKE 采用的验证机制是双向的。</font></p><h3 id="edfd47be"><font style="color:rgb(43, 56, 53);">被动进入和启动系统（PEPS，Passive Entry Passive Start）</font></h3>**工作原理**<font style="color:rgb(43, 56, 53);">：</font><ol><li><strong>进入车辆</strong><font style="color:rgb(43, 56, 53);">：</font><ul><li><font style="color:rgb(43, 56, 53);">工作原理与PKE 相同，车辆会发送LF信号，钥匙响应并发送HF信号，车辆验证并解锁车门。</font></li></ul></li><li><strong>启动车辆</strong><font style="color:rgb(43, 56, 53);">：</font><ul><li><font style="color:rgb(43, 56, 53);">当用户进入车内并按下启动按钮时，车辆会再次发送LF信号以确认钥匙是否在车内。</font></li><li><font style="color:rgb(43, 56, 53);">钥匙响应并发送HF信号，车辆验证识别码。</font></li><li><font style="color:rgb(43, 56, 53);">如果识别码匹配，车辆的ECU允许启动引擎。</font></li></ul></li></ol><p><strong>技术</strong><font style="color:rgb(43, 56, 53);">：</font></p><ul><li><font style="color:rgb(43, 56, 53);">结合PEK的所有技术。</font></li><li><font style="color:rgb(43, 56, 53);">通过车辆内的多个天线阵列实现更精确的钥匙定位，确保钥匙在车内时才能启动引擎。</font></li></ul><p><font style="color:rgb(43, 43, 43);">PEPS 是一种安全的无线通信系统，可使驾驶员在不使用钥匙的情况下进入汽车，解锁汽车并启动发动机。该系统使用射频信号，通过在汽车和钥匙之间发送信号来验证钥匙。PEPS 系统使用低频无线电波（通常为 125 千赫或 134 千赫）和超高频（UHF）无线电波（通常为 1 千兆赫以下的信号）进行双向通信，在钥匙和汽车之间交换唯一的钥匙访问代码。一旦交换的代码符合预期值，且钥匙在汽车附近，汽车就会允许驾驶员进入。系统还会测量汽车与钥匙之间的距离，以确定钥匙是在车内还是车外。这一信息可用于为驾驶员提供不同类型的访问权限。例如，如果钥匙在车外，则只允许进入车内，但发动机启动功能将不起作用。基本上，目前主流的 PEPS 都已集成了 NFC 和蓝牙功能。驾驶员可将 NFC 手机放在汽车 B 柱附近，然后进入车内。这消除了将钥匙扣和智能手机都放进口袋的麻烦。但将蓝牙引入 PEPS 则更具革命性。蓝牙的高频率、跳频机制和强化的安全机制与 UHF&#x2F;LF 的保证机制相比，提供了更多的安全保证。此外，蓝牙的测距和定位功能对掌握开关门的时机大有帮助。蓝牙测距和定位的精度可达半米或一米。它包括 RSSI 方法和 AoA 方法。前者精度较低，可达到 1 至 5 米的精度水平。后者精度更高，精度可达半米。</font></p><h3 id="8fcda306"></h3><h1 id="bRzv6">二.滚动码机制</h1>虽然汽车无钥匙进入系统已经发展了很多年，但是采用 RKE 依然大量存在。并且，由于滚动码机制的特殊性。在现如今依然存在大量使用滚动码的地方。因此，研究滚动码机制依然是非常有价值和意义的。<p>应用滚动码技术意味着每一个键的fob信号传输都是唯一的，即它随着每按一个按钮而变化。唯一性是通过在钥匙中心（以及在接收时的车辆中）增加一个16位宽计数器来实现的。如果两边的计数器都同步，则按下按钮有效。然后，每个方增加其计数器以同步按下以下按钮。因此，如果攻击者捕获了从钥匙中心发送的有效信号，并由车辆用计数器Ck &#x3D; n接收并重放它，它将被车辆中的接收器丢弃，作为其计数器Cv &gt; Ck，即Cv&#x3D;（n+&#x3D;）：k&gt;0。</p><p>另一方面，当钥匙扣超出车辆范围时，需要按下按钮，即使用钥匙扣来锁定&#x2F;解锁汽车和Ck &gt; Cv。这些情况被进一步分为两个不同的操作窗口</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010253895.webp">        </p><h3 id="2c60edda">单一窗口</h3>**单一窗口**是指计数器差值 _<font style="color:rgb(0,0,0);">Cdif f </font>_<font style="color:rgb(0,0,0);">= </font>_<font style="color:rgb(0,0,0);">Ck − Cv</font>_ 较小的情况。具体来说，当差值小于16时（即 _<font style="color:rgb(0,0,0);">Cdif f < </font>_<font style="color:rgb(0,0,0);">16</font>），系统可以在第一次按键按下时立即进行同步。这意味着当车辆接收到钥匙扣的信号后，它会立即更新自己的计数器，与钥匙扣的计数器保持一致，不需要额外的步骤。<p><strong>主要特点：</strong></p><ul><li><strong>同步快速</strong>：只需一次按键操作。</li><li><strong>差值较小</strong>：差值在16以内，车辆可以轻松同步。</li><li><strong>即时更新</strong>：车辆会立即更新其计数器，丢弃在这之前所有未接收到的代码。</li></ul><h3 id="8ede463a">重新同步/双窗口</h3>**重新同步/双窗口**是指计数器差值较大的情况。具体来说，当差值在<font style="color:rgb(0,0,0);">16 </font>_<font style="color:rgb(0,0,0);">< Cdif f < </font>_<font style="color:rgb(0,0,0);">2 15</font>时，系统需要进行重新同步。<p><strong>主要特点：</strong></p><ul><li><strong>同步需要两次按键操作</strong>：当车辆接收到一次信号时，暂时存储这个信号并等待下一次信号。如果下一次信号的计数器值比上次大1，则系统进行同步。</li><li><strong>差值较大</strong>：差值在16到<font style="color:rgb(0,0,0);">2 15</font>之间，车辆需要额外的验证步骤来确保安全。</li><li><strong>双步验证</strong>：车辆需要接收到两次连续的信号才能完成同步，从而提高了安全性，防止信号被重放攻击。</li></ul><p>如果上述任何一个失败，则车辆接收到的钥匙焦点信号被丢弃。此外，请注意，由于底层的加密机制即使是一位信息的变化（例如，计数器增量）也会导致最终传输信号的显著变化。因此，攻击者通过捕获上一个信号来推断下一个有效的解锁信号，这在计算上是不可行的。</p><p>请注意，当钥匙 fob 已经发出信号时，已发送的代码也可以被认为未使用，但车辆没有收到它。例如，当解锁按钮被意外按下时。（由图1a中的“解锁代码n+2”和“n+3”描述）。**为了避免不同步，从而在这种情况下将我们自己锁在我们的车辆之外，基于滚动代码的系统提供了一个安全功能，允许钥匙fob的计数器比车辆的计数器领先一步。**这是通过在车辆上维护的不是一组，而是一组有效的“未来代码”来实现的 。如果从钥匙fob接收到的代码与这些未来的代码匹配，车辆将重新同步到最后一个钥匙fob信号中的代码，并使该集合中所有以前（但未使用的）代码失效（参见图中的“解锁代码n+4”）。<strong>显然，如果攻击者可以获得这些未使用的未来代码之一（即，捕获汽车附近的意外按钮按下的信号），并且她可以在车主再次使用钥匙fob之前重播它，攻击者可以访问车辆</strong>。然而，在实践中获取这些未来的代码是极其困难的，特别是当攻击者想要瞄准一个随机的受害者时。这就是为什么这种安全配置被认为是一个方便的特性，使关键的fob使用无缝和更少的麻烦</p><h1 id="tpDwp">三.rollback 与 rolljam 工作机制探讨</h1>虽然理论上滚动码机制是一项安全的技术。但是在 2015 年一种名为 rolljam 的技术证明了基于滚动码的密钥系统是极易破坏的。简而言之，根据 rolljam 的原理破解滚动码系统只需要三个步骤：干扰，捕捉，重放.<p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010257869.webp"></p><p>如上图 rolljam 部分的流程图所示，它分为四个步骤</p><ol><li>时刻捕捉信号</li><li>采用特定设备干扰车辆与钥匙的正常通信</li><li>因为干扰，从而引诱车主第二次发送解锁信号</li><li>重放先前捕获的第一次信号</li></ol><p>回顾一下这整个过程是怎么实现的。首先我们拥有一个可以实现干扰，捕捉，重放的设备。在攻击模型当中，受害者由于步骤三会按下两次解锁按钮。同时我们会得到两个滚动码，此时我们再重放第一次接收到的滚动码就可以攻击成功。为什么这个滚动码是有效的？还记得在上面的滚动码原理吗。由于滚动码是一次性的且必须按顺序使用，拦截并阻止一个滚动码后，合法用户的遥控器会发送下一个滚动码。这导致接收设备并没有意识到有一个滚动码已经被阻塞并存储下来。钥匙发送的信号并没有被车辆所接收到，这在滚动码设计当中是被允许的。因此，这个接收到的滚动码被判定为有效。攻击成功。</p><p>但是这样的作法存在很大的缺点：</p><ol><li>首先在这个攻击模型当中阻塞的作用非常关键。倘若阻塞装置不能很好的阻塞合法信息的通信，我们所收集到的滚动码会因此作废。这就导致了对阻塞装置的放置有很高的要求</li><li>与条件一类似。必须在收集信号完成后及时的使用它。否则它会随着滚动的信号更新而失效，整个攻击流程必须从头开始</li></ol><p>针对 rolljam 的以上缺点另外一种名为 rollback 的机制被提出。顾名思义它叫做回滚，利用的便是滚动码当中的回滚机制。在不同的 RKE 系统当中回滚系统都不同。但是存在回滚机制的系统原理都是当<strong>多个已经连续被发送过的滚动码被重新发送</strong>，这个时候滚动码系统认为自身出现了错误，从而回滚到之前的已经被使用过的滚动码。这个过程如上图中右图所示。与 rolljam 的工作步骤类似：</p><ol><li>时刻捕捉信号</li><li>采用特定设备干扰车辆与钥匙的正常通信</li><li>因为干扰，从而引诱车主第二次发送解锁信号</li></ol><p>然而我们并不需要第四个步骤，因为回滚机制的存在。我们可以在任意时间重放这个滚动码,这个滚动码都有效。</p><h1 id="X0O1Z">四.基于 esp32 的 rollback 与 rolljam 攻击原理的 CTF 题目</h1><h4 id="a0PWI">硬件部分</h4>esp32+cc1101 x2<p>一个 SDR(RTL-SDR 即可</p><p>rolljam 和 rollback 设备，这里使用的是自制的 EvilcrowRF</p><h4 id="rnHpL">软件部分</h4>[https://github.com/ch0en3/rollback-rolljam_ctf]<p>感兴趣的师傅可以玩一下</p>]]></content>
    
    
    <summary type="html">滚动码系统研究
</summary>
    
    
    
    <category term="car-hacking" scheme="https://ch0en3.github.io/categories/car-hacking/"/>
    
    
    <category term="car-hacking" scheme="https://ch0en3.github.io/tags/car-hacking/"/>
    
  </entry>
  
  <entry>
    <title>一次无线电分析经历</title>
    <link href="https://ch0en3.github.io/2025/03/%E4%B8%80%E6%AC%A1%E6%97%A0%E7%BA%BF%E7%94%B5%E5%88%86%E6%9E%90%E7%BB%8F%E5%8E%86/"/>
    <id>https://ch0en3.github.io/2025/03/%E4%B8%80%E6%AC%A1%E6%97%A0%E7%BA%BF%E7%94%B5%E5%88%86%E6%9E%90%E7%BB%8F%E5%8E%86/</id>
    <published>2025-03-15T16:58:09.515Z</published>
    <updated>2025-03-15T17:28:21.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nL9lG">利用URH的步骤</h3><ol><li>记录信号</li><li>信号说明</li><li>信号分析</li></ol><p>首先找到通过URH自带的频谱分析器寻找到系统通信的中心频率。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011842426.png"></p><p>找到中心频率后利用记录信号工具捕获信号。urh可以记录从sdr中捕获的原始音频信号。</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011844967.png"></p><p><font style="color:rgb(13, 13, 13);">过放大捕获的音频信号并观察清晰的正弦波形以及非平凡的模式，可以验证捕获很可能是正确的</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011847379.png"></p><p>一旦信号被捕获到就可以利用URH的发送信号工具进行重播</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011849682.png"></p><h2 id="w1KdN">逆向工程RF协议</h2><font style="color:rgb(13, 13, 13);">所讨论的系统使用 RF 信号在设备之间进行无线通信。这些无线电波用于在每个设备之间传输二进制数据，即 0 和 1。通过无线电波传输二进制数据的过程称为调制 。</font><p><font style="color:rgb(13, 13, 13);">有三种主要的简单调制二进制信号的方式：幅度键控 (ASK)、频率键控 (FSK) 和相位键控 (PSK)。它们分别产生不同的波形，可以很容易地通过视觉识别。如图所示。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011852263.png"></p><p><font style="color:rgb(13, 13, 13);">每种技术都使用正弦波的不同属性来分别编码零和一。幅度键控 (ASK) 使用波的振幅，其中较高的振幅通常编码为 1，较低的振幅编码为 0。频率键控 (FSK) 则保持振幅和相位不变。而是在两个不同的频率之间进行切换以区分 0 和 1。最后，相位键控 (PSK) 使用相位变化来区分这两个符号。</font></p><p><font style="color:rgb(13, 13, 13);">解调是将调制信号转换回原始二进制数据的过程。在 RF 通信的大多数实际应用中，这是直接在硬件中完成的，使用专门的无线电接收器和电路自动将信号转换回二进制数据 。通常，该硬件还实现了错误校正、噪声过滤和其他技术，以增加通信的可靠性，因为干扰和其他干扰在现实世界中是不可避免的。</font></p><p><font style="color:rgb(13, 13, 13);"></font></p><p><font style="color:rgb(13, 13, 13);">urh可以自动解调，但是很多时候无法找到正确的调制参数。因此我们可以使用audacity进行手动解调。</font></p><p><font style="color:rgb(13, 13, 13);">解调的步骤如下：</font></p><ol><li><font style="color:rgb(13, 13, 13);">将 URH 捕获的原始信号数据通过菜单选项文件 - 导入 - 原始数据导入到 Audacity 中。URH 将信号保存为有符号 8 位字节的原始 IQ 数据。通过选择编码为有符号 8 位 PCM 的 2 通道 (立体声)，可以将数据的 I 和 Q 组件分开并导入到两个单独的轨道中。在这种情况下，仅使用其中一个足以提取信息。因此，在 Audacity 中，将立体声轨道拆分为两个单声道轨道，然后删除第二个轨道。导入选项的其余部分并不重要。</font></li><li><font style="color:rgb(13, 13, 13);">其次，记录 Audacity 感知到的中心频率。可以通过菜单选项分析 - 绘制频谱来找到这一点。注意，由于样本率等多个特征不是原始信号数据的一部分，因此此频率可能不等于实际的 868.64 MHz 的中心频率。在下面的步骤中使用了这个频率。</font></li><li><font style="color:rgb(13, 13, 13);">对第一个轨道应用高通滤波器，并对第二个轨道应用低通滤波器，将滚降值设置为 48 dB。前者基本上将较高的频率映射到输出波中的较高振幅，后者则相反。</font></li><li><font style="color:rgb(13, 13, 13);">使用 Audacity 的脚本语言 Nyquist 对每个轨道应用绝对值。使用了简短的 Nyquist 程序 (s-abs </font><em><font style="color:rgb(13, 13, 13);">track</font></em><font style="color:rgb(13, 13, 13);">) 来实现。然后对两个轨道应用了低通滤波器，计算了信号的包络。最后，对最初应用了低通滤波器的轨道进行了反转。这意味着现在两个轨道分别对应于原始信号的高频和低频部分。</font></li><li><font style="color:rgb(13, 13, 13);">接下来，将两个轨道混合到一起形成一个新轨道，即将信号相加。</font></li><li><font style="color:rgb(13, 13, 13);">将混合轨道放大到尽可能高的程度，并启用剪切，以创建一个二进制信号。这创建了最终信号，即从原始信号解调出的原始二进制信号。</font></li><li><font style="color:rgb(13, 13, 13);">最后，将最终的二进制波形导出为原始数据到文件中。通过选择最终轨道并使用菜单选项文件 - 导出 - 导出所选音频 来完成。在随后的文件对话框中，选择”其他未压缩文件”作为类型，并选择无标题 (例如 RAW)，并选择有符号 8 位 PCM 编码。这样就可以将信号导出为原始二进制振幅数据，表示为有符号字节。</font></li></ol><p><font style="color:rgb(13, 13, 13);"></font></p><p><font style="color:rgb(13, 13, 13);">这就是解调信号的过程</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011854887.png"></p><p>经过此过程的结果是一个二进制波形而不是一段实际的二进制数据,因此编写了一个简单的python程序用于提取</p><pre><code class="language-c">import matplotlib.pyplot as pltSIGNAL_LEN, SYMBOL_LEN = 34000, 200FILE, SIGNAL_OFFSETS = &quot;door-signal.raw&quot;, [1800, 856160, ...]with open(FILE, &quot;rb&quot;) as f:signal = [b if b &lt; 128 else b - 256 for b in f.read()]for i, offset in enumerate(SIGNAL_OFFSETS):xs = range(offset, offset + SIGNAL_LEN, SYMBOL_LEN)plt.scatter(xs, [0 for _ in xs], c=&quot;red&quot;)bits = &quot;&quot;.join([&#39;1&#39; if signal[x] &gt; 0 else &#39;0&#39; for x in xs])print(f&quot;Packet &#123;str(i).ljust(2)&#125; =&quot;, hex(int(bits, 2)))plt.plot(signal)plt.show()</code></pre><p><font style="color:rgb(13, 13, 13);">该程序期望一个 x 轴偏移值列表，其中包含信号的第一个比特位。这些值是手动找到的，通过手动查看程序创建的图来实现。信号长度和符号长度也是手动测量的，但这些对于所有捕获的信号来说是恒定的。只需手动推导出每个信号的信号起始偏移量，这相当耗时。因此，这个过程仅应用于少数信号，直到收集到足够的信息来对协议做出结论。</font></p><p><font style="color:rgb(13, 13, 13);"></font></p><p><font style="color:rgb(13, 13, 13);">通过使用 Audacity 和描述的方法，从每个记录的信号中提取了二进制数据。这些数据以十六进制形式呈现在表中。分析数据后可以看到一个非常清晰的结构。所有记录的信号解码后都恰好为 170 位，并且始终具有以下结构。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011858946.png"></p><ol><li><font style="color:rgb(42, 43, 46);">1和0交替的序文。这是射频协议中非常常见的技术，用于通知传入信号并同步时钟频率</font></li><li><font style="color:rgb(42, 43, 46);">对于每个设备都是恒定的字节序列。例如，门传感器将始终发送相同的字节序列，摄像机将发送另一个字节序列，等等。这对应于一个同步字，它经常在射频协议中发现，用于确定协议类型或消息来自哪个设备。据推测，这是某种ID，用于告诉主面板该消息来自哪个外设。</font></li><li><font style="color:rgb(13, 13, 13);">一系列零位。据推测，这是同步字的一部分。这也是 RF 协议中常见的技术，用于让接收器知道这是什么协议，以及有效载荷数据从何处开始。</font></li><li><font style="color:rgb(42, 43, 46);">一串看似随机的比特，可能是有效载荷</font></li></ol><p><font style="color:rgb(147, 149, 153);"></font></p><p><strong>门防拆传感器开启</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000015d477e072b922530064</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a0000028648b07e291d2ceecc</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a0000280b9d2e1d2d2ca7f31c</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00002548c662f2feeea7fe22</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000019201db301398d538674</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00000806d6a5ee37481e2f76</font></li></ul><p><strong>门防拆传感器关闭</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a0000102366a5cb78d61c0d0c</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00000a3b2cb0867bf62aa616</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000028fe2271f089a9e8c984</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00001e23195bcbe8c65107ec</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a00001913b1ee7e3448da1cf0</font></li><li><font style="color:rgb(13, 13, 13);">0xaaaaaaaa29cd29cd0a000006f69dbb732deb2a120c</font></li></ul><p><strong>摄像头防拆传感器开启</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a14000034164758f44cfae66f1</font></li></ul><p><strong>摄像头防拆传感器关闭</strong></p><ul><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li><li><font style="color:rgb(13, 13, 13);">0x155555554539a539a140000342724d66fce053d3d7</font></li></ul><p><font style="color:rgb(13, 13, 13);">然而，payload 显然被加密或至少以某种方式混淆了。实际方法是什么，以及它是否是一个加密安全的方法，这些问题都没有答案。加密可能很弱。在没有固件或关于 RF 协议的其他文档的情况下进一步的逆向工程几乎是不可能的。</font></p><h3 id="sgsxl"><font style="color:rgb(13, 13, 13);">RF 干扰攻击</font></h3><font style="color:rgb(13, 13, 13);">无线电频谱是用于无线通信的介质。它本质上容易受到干扰攻击的影响。这可以类比于 RF 版本的 DoS 攻击。对 RF 通信进行干扰攻击涉及将电磁能量定向到一个或多个无线电频率，以干扰或阻止两个系统之间的信号传输。在实践中，这意味着在特定频率上发送信号，携带足够的能量来击败在相同频段传输的任何人。通过持续发送信号，使无线频段充满，可以阻止合法的流量。</font><p><font style="color:rgb(13, 13, 13);">由于 RF 通信使用共享介质，因此这是一种非常难以防范的攻击。通常，系统将在单一固定频率上进行通信，这可能使系统特别容易受到干扰攻击。尽管已经开发出许多复杂的技术来检测干扰，但检测和报告仅限于系统对干扰攻击的反应程度。通常情况下，除了可能切换频率带或切换到备用通信模式外，很少能做其他事情。</font></p><h4 id="DcPZp"><font style="color:rgb(13, 13, 13);">方法</font></h4><font style="color:rgb(13, 13, 13);">为了发送信号，使用了 HackRF SDR。它被放置在系统附近，距离在 10-20 厘米之间。使用了开源程序 GnuRadio Companion。这是一个图形工具，用于控制 SDR。它基于创建连接组件的流图，用于接收、处理、修改和发送来自和到 SDR 的实时无线电信号。</font><p><font style="color:rgb(13, 13, 13);">为了生成噪声信号，在 GnuRadio Companion 中创建了一个流图，如图所示。</font></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316011901996.png"></p><p><font style="color:rgb(13, 13, 13);">首先，使用快速噪声发生器作为源信号。然后将噪声输出链接到低通滤波器，以将信号集中到感兴趣的特定频率带。最后，将输出发送到 HackRF 通过 osmocom Sink 块。此外，低通滤波器的输出还发送到一个 QT GUI 频率接收器，以在执行攻击时可视化呈现发送信号数据。</font></p>]]></content>
    
    
    <summary type="html">这是一篇关于无线电分析经历的简要介绍。</summary>
    
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>无线电安全入门-以固定码为例展示如何分析无线电协议</title>
    <link href="https://ch0en3.github.io/2025/03/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8-%E4%BB%A5%E5%9B%BA%E5%AE%9A%E7%A0%81%E4%B8%BA%E4%BE%8B%E5%B1%95%E7%A4%BA%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%97%A0%E7%BA%BF%E7%94%B5%E5%8D%8F%E8%AE%AE/"/>
    <id>https://ch0en3.github.io/2025/03/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8-%E4%BB%A5%E5%9B%BA%E5%AE%9A%E7%A0%81%E4%B8%BA%E4%BE%8B%E5%B1%95%E7%A4%BA%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E6%97%A0%E7%BA%BF%E7%94%B5%E5%8D%8F%E8%AE%AE/</id>
    <published>2025-03-15T16:57:41.395Z</published>
    <updated>2025-03-15T17:28:37.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pjf0P">一.前言</h1><p>这篇文章的由来来自于对一个固定码的无线信号进行分析时候发现的一个现象，并由此文记录下从发现问题到解决问题的完整过程。</p><p>为了更方便理解 以下是本文当中出现的所有设备</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010127668.jpeg"></p><p>它们依照从左到右的顺序为 RTL-SDR，RSP1，esp32，无线门铃</p><p>以下会以 sdr 来替代 rtl-sdr 和 rsp1.</p><p>文中所用软件：universal radio hacker,cc1101-tool</p><h1 id="fUNRT">二:问题由来</h1>本次分析的目标是收集目标设备发送的信号并且进行重放。由于在前言当中提到的 sdr 设备只有接收信号的功能而并不能发送信号，因此我采用了 esp32 搭配 cc1101 来完成信号的发送。为了实现这个目的，我需要将 sdr 接收到的调制信号转换为十六进制字符串并且输入到我的 esp32 设备当中。<p>第一步做的事情是收集信号并且分析。</p><p>以下的所有详细分析过程可以观看 b 站视频(<a href="https://www.bilibili.com/video/BV11YULYjEfy),%E8%BF%99%E9%87%8C%E4%B8%8D%E8%BF%87%E5%A4%9A%E8%B5%98%E8%BF%B0">https://www.bilibili.com/video/BV11YULYjEfy),这里不过多赘述</a></p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010139766.png"></p><p>可以看到我们接收到的信号是这样的。</p><p>第二步我们要把数据转换为正确的形式，按照原理，转换后我们应该会得到这样的一些信号</p><p>80000000（这是由于前面还有一小段脉冲 但是由于过滤没有被显示 要加上）</p><p>8e88eeee88ec7477477747740000000</p><p>8e88eeee88ee8e8ee8eee8ee80000000</p><p>8e88eeee88ee8e8ee8eee8ee0000000</p><p>接着我们要把 urh 分析得到的序列号填写进我们的 esp 设备当中</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010147022.png"></p><p>可以看到这里共有十六个由小脉冲信号组成的大脉冲信号，我们只需要按照如图所示的顺序填入我们的 esp32 当中即可。</p><p>那么填完后 esp32 当中缓冲区内的数据应该是这样的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010150003.png"></p><p>此时我们能够正常激活目标设备</p><p>但是我们还有第二种方法也能够实现同样的目标，使用 esp32 自带的记录功能并且重放</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010152181.png"></p><p>可以看到我们成功的记录下了信号并且将其保存在缓冲区当中</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010154432.png"></p><p>并且也能够成功执行</p><p>于是问题产生了，我们可以很明显的发现缓冲区当中的数据和我们开始的数据并不一样。但为什么也能够正常执行？</p><p>使用 URH 进行观察，我们用 URH 捕获 esp32 重放的信号。发现它是这样子的</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010156622.png"></p><p>那么通过观察我们可以发现 这三段信号都不一样。为什么都能够触发设备？</p><h1 id="zpJN9">三.研究过程</h1>分别分析三段信号，以下按照如上文章顺序我们分别命名为 原始信号，esp32 接收信号，esp 32 发出信号<pre><code class="language-plain">8e88eeee88ec7477477747748e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee88e88eeee88ee8e8ee8eee8ee</code></pre><pre><code class="language-plain">800000008E007777447FA3A3BA3BFD1DD000000010E88EEEE8C7747477C3BBA3BA000000011D11DDFE88EE8E8F747774774000000023A23DDDD11DD1F8EE8EEE8F74000000047403BBBA23FC1D1DD1DDE0EE8000000087447777447BA3A3BA3DDD1DD000000008E88EEEF847747477A3BBA3BA000000011D11DFEE88EE8F877477747FA000000023A21DDDD11DF0E8EE8EEE8774000000047823BBBA23DD1D1DD1FEE8EE80000000C7447777423BA3A3BE1DDD1DD000000008E88EFFF44774747BA3BBA3BC000000011D11EEEE88EE8FC77477747BA000000023801DDDD11FE8E8EE8FFF4774000000043A23BBBA01DD1D1DD0EEE8EE80000000474477FFA23BA3A3DD1DDD1DE  </code></pre><pre><code class="language-plain">8e8077774477c3a3ba3bbe1dd8f047777447ba3a3ba3fdd1dd8e88eeee047747477c3bba3ba8e88eeffa23ba3a3dd1ddd1df8e88f777447747a3ba3bba3dd8e807777447ff1d1dd1ddf8ee887447777447ba3a3ba3fdd1dd8e88eeef847747477c3bba3ba8e88eeff44774747ba3bba3ba8e88ff77447747c3ba3bba3fd8e887777447747a3ba3bbc7748eeeee88ff47477477fa3ba87447777443ba3a3ba3ddd1dd8e88eeef047747477e3bba3ba8e88eff744774747ba3bba3bf8e88f777447747a3ba3bba3fc</code></pre><p>来比较他们的异同，可以发现一些有趣的情况</p><ol start="2"><li><strong>共同部分与差异分析</strong></li></ol><ul><li><strong>共同特征</strong>：在所有三段信号中，都能找到一些类似的字节序列，例如 <code>8e88</code>, <code>eeee</code>, <code>7747</code>, 以及 <code>ba3b</code>。这些序列可能是信号中用来识别的关键特征。</li><li><strong>差异</strong>：在每一段信号中，存在大量的变化和不同之处，尤其是在中间部分。这些差异可能是由于信号存储设备的处理方式不同，或者是由于设备在不同时间接收到的信号有所不同。</li></ul><ol start="3"><li><strong>关键部分识别</strong></li></ol><ul><li><strong>核心部分可能性</strong>：<ul><li>在第一段信号中，<code>8e88eeee88ee8e8ee8eee8ee8</code> 这一部分反复出现，并且在最后一行 <code>8e88eeee877474774777477</code> 中的 <code>8e88eeee</code> 和 <code>7747</code> 出现频率较高，这表明这一部分可能是触发门铃的关键部分。</li><li>第二段信号中的 <code>8e88eeee047747477c3bba3ba</code> 和第三段信号中的 <code>8e88eeee8C7747477C3BBA3BA</code> 也都包含类似的 <code>8e88</code> 和 <code>7747</code>，这进一步表明这些序列可能是关键。</li></ul></li></ul><p>可以发现不管是哪一段信号当中都出现有 <code>8E88EEEF</code> 和 <code>84774747</code>，那么这是否意味着<code>8E88EEEF</code> 和 <code>84774747</code> 就是触发门铃信号的关键？</p><p>可以做个简单的实验。仿照esp32接收信号的格式，我们生成一段新的随机字符串</p><pre><code class="language-plain">800000008E88EFFF84774747C3BBA3BA000000011D11DFEE88EE8F877477747FA000000023A21DDDD11DF0E8EE8EEE8774000000047823BBBA23DD1D1DF8EE8EEE8F74000000047403BBBA23FC1D1DD1DDE0EE8000000087447777447BA3A3BA3DDD1DD000000008E8 8EEEF84774747C3BBA3BA000000011D11DFEE88EE8F877477747FA000000023A21DDDD11DF0E8EE8EEE8774000000047823BBBA23DD1D1DF8EE8EEE8F74000000047403BBBA23FC1D1DD1DDE0EE80000000C7447777423BA3A3BE1DDD1DD000000008E88EFFF84774747BA3BBA3BC000000011D11EEEE88EE8FC77477747BA000000023801DDDD11FE8E8EE8FFF4774000000043A23BBBA01DD1D1DD0EEE8EE80000000474477FFA23BA3A3DD1DDD1DE</code></pre><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010200841.png"></p><p>可以发现触发成功</p><p><img src="https://ch0en3.oss-cn-nanjing.aliyuncs.com/20250316010202646.png"></p><h1 id="rv6jm">四.结论</h1>通过我们实验可以发现`8E88EEEF` 和 `84774747`就是触发设备的核心部分。那么为什么在不同的数据当中会有如此之多的不同数据出现？<p>这就涉及到了无线信号的冗余和容错机制。</p><p>由于在现实生活当中存在非常多的干扰不能够完全的确保发送的无线电信号能够正确的被接收端接收到，因此我们需要冗余和容错机制。</p><ul><li><strong>冗余编码</strong>：许多无线设备发送信号时都会加入大量冗余数据，以增强信号在噪声或干扰环境中的可靠性。这些冗余数据使得即使信号在某些部分发生了改变或丢失，接收设备仍然能够正确识别。</li><li><strong>容错能力</strong>：门铃的接收器可能有一定的容错能力，只要收到的信号大致匹配，就会触发门铃。因此，虽然两个信号在细节上有差异，但只要它们在某些关键特征上符合预期，就能成功触发门铃。</li><li><strong>信号帧结构</strong>：有些无线设备的信号由多个帧组成，每个帧包含控制信息、数据部分和校验信息。即使不同设备对这些帧的解析结果不同，只要接收器能够正确识别某些帧，就能触发动作。</li></ul><p>通过上述一系列实验，那么我们可以得到一个对无线电协议分析的一个结论。在研究无线电信号协议的时候一个目的就是找到无线电信号当中信号的一个有效的部分</p>]]></content>
    
    
    <summary type="html">以固定码为例展示如何分析无线电协议</summary>
    
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="无线电安全入门" scheme="https://ch0en3.github.io/tags/%E6%97%A0%E7%BA%BF%E7%94%B5%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客&amp;闲谈</title>
    <link href="https://ch0en3.github.io/2025/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E9%97%B2%E8%B0%88/"/>
    <id>https://ch0en3.github.io/2025/03/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2-%E9%97%B2%E8%B0%88/</id>
    <published>2025-03-15T16:39:47.824Z</published>
    <updated>2025-03-15T16:51:49.170Z</updated>
    
    <content type="html"><![CDATA[<p>写博客的想法一早就有了因为懒所以鸽了很久（主要语雀比较方便<br>转移一些语雀上的文章和随笔,也算是在互联网上留下个人痕迹了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写博客的想法一早就有了因为懒所以鸽了很久（主要语雀比较方便&lt;br&gt;转移一些语雀上的文章和随笔,也算是在互联网上留下个人痕迹了&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://ch0en3.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
